
// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Factories\ConsumerServiceFactoryTests.cs

using Microsoft.Extensions.DependencyInjection;
using RCS.RabbitMq.Consumer.Factories;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Tests.Consumer.Models;
using RCS.RabbitMq.Tests.Consumer.Utilities;
using RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Factories
{
    public class ConsumerServiceFactoryTests
    {
        [Fact]
        public void Create_Should_Throw_For_Unknown_MessageType()
        {
            var provider = new ServiceCollection().BuildServiceProvider();
            var factory = new ConsumerServiceFactory(provider);
            Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(string)));
        }
        [Fact]
        public void Create_Should_Succeed_For_Valid_LogMessage()
        {
            var provider = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, ILogMessage>();
            var factory = new ConsumerServiceFactory(provider);
            var service = factory.Create(typeof(FakeLogMessage));
            Assert.NotNull(service);
        }
        [Fact]
        public void Create_Should_Throw_When_Logger_Is_Missing()
        {
            var provider = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, FakeLogMessage>(
                includeLogger: true,
                includeConnection: true,
                includeScalingQueue: true,
                includeConsumerSettings: true,
                includeDataProcessor: true
            );
            var factory = new ConsumerServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            Assert.Contains("No service for type", ex.Message);
        }
        [Fact]
        public void Create_Should_Throw_When_ConsumerManager_Is_Missing()
        {
            var provider = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, FakeLogMessage>(includeConsumerManager: false);
            var factory = new ConsumerServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            Assert.Contains("ConsumerManager", ex.Message, StringComparison.OrdinalIgnoreCase);
        }
        [Fact]
        public void Create_Should_Throw_When_DataProcessor_Is_Missing()
        {
            var provider = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, FakeLogMessage>(
                includeDataProcessor: false,
                includeConnection: true,
                includeScalingQueue: true,
                includeConsumerSettings: true
            );
            var factory = new ConsumerServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            
            Assert.Contains("No service for type", ex.Message);
        }
        [Fact]
        public void Create_Should_Throw_When_RabbitMqSettings_Is_Missing()
        {
            var provider = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, FakeLogMessage>(
                includeRabbitMqSettings: false,
                includeLogger: true,
                includeConsumerManager: true,
                includeConsumerSettings: true,
                includeConnection: true,
                includeDataProcessor: true,
                includeScalingQueue: true
            );
            var factory = new ConsumerServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            Assert.Contains("No service for type", ex.Message);
        }
        [Fact]
        public void Create_Should_Throw_When_ConsumerSettings_Is_Missing()
        {
            var provider = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, FakeLogMessage>(
                includeConsumerSettings: false,
                includeScalingQueue: true,
                includeConnection: true
            );
            var factory = new ConsumerServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            
            Assert.Contains("No service for type", ex.Message);
        }
        [Fact]
        public void Create_Should_Throw_When_ScalingQueue_Is_Missing()
        {
            var provider = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, FakeLogMessage>(
                includeScalingQueue: false,
                includeConnection: true 
            );
            var factory = new ConsumerServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            
            Assert.Contains("No service for type", ex.Message);
        }
        [Fact]
        public void Create_Should_Throw_When_Connection_Is_Missing()
        {
            var provider = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, FakeLogMessage>(
                includeConnection: false,
                includeScalingQueue: true 
            );
            var factory = new ConsumerServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            
            Assert.Contains("No service for type", ex.Message);
        }
        [Fact]
        public void Create_Should_Succeed_For_Valid_WhatsAppMessage()
        {
            var provider = TestHelper.BuildValidConsumerServiceProvider<FakeWhatsAppMessage, IWhatsAppMessage>();
            var factory = new ConsumerServiceFactory(provider);
            var service = factory.Create(typeof(FakeWhatsAppMessage));
            
            Assert.IsType<ConsumerService<FakeWhatsAppMessage, IWhatsAppMessage>>(service);
        }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Factories\MonitoringServiceFactoryTests.cs

using RCS.RabbitMq.Consumer.Factories;
using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Tests.Consumer.Models;
using RCS.RabbitMq.Tests.Consumer.Utilities;
using RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Factories
{
    public class MonitoringServiceFactoryTests
    {
        [Fact]
        public void Create_Should_Throw_For_Unknown_MessageType()
        {
            var provider = TestHelper.BuildValidServiceProvider<FakeLogMessage, ILogMessage>();
            var factory = new MonitoringServiceFactory(provider);
            var unknownType = typeof(string);
            Assert.Throws<InvalidOperationException>(() => factory.Create(unknownType));
        }
        [Fact]
        public void Create_Should_Succeed_For_Valid_LogMessage()
        {
            var provider = TestHelper.BuildValidServiceProvider<FakeLogMessage, ILogMessage>();
            var factory = new MonitoringServiceFactory(provider);
            var ex = Record.Exception(() => factory.Create(typeof(FakeLogMessage)));
            Assert.Null(ex);
        }
        [Fact]
        public void Create_Should_Succeed_For_Valid_WhatsAppMessage()
        {
            var provider = TestHelper.BuildValidServiceProvider<FakeWhatsAppMessage, IWhatsAppMessage>();
            var factory = new MonitoringServiceFactory(provider);
            var ex = Record.Exception(() => factory.Create(typeof(FakeWhatsAppMessage)));
            Assert.Null(ex);
        }
        [Fact]
        public void Create_Should_Throw_When_Logger_Is_Missing()
        {
            var provider = TestHelper.BuildValidServiceProvider<FakeLogMessage, ILogMessage>(includeLogger: false);
            var factory = new MonitoringServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            Assert.Contains("ILogger", ex.Message, StringComparison.OrdinalIgnoreCase);
        }
        [Fact]
        public void Create_Should_Throw_When_ConsumerManager_Is_Missing()
        {
            var provider = TestHelper.BuildValidServiceProvider<FakeLogMessage, ILogMessage>(includeConsumerManager: false);
            var factory = new MonitoringServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            Assert.Contains("ConsumerManager", ex.Message, StringComparison.OrdinalIgnoreCase);
        }
        [Fact]
        public void Create_Should_Throw_When_RabbitMqSettings_Is_Missing()
        {
            var provider = TestHelper.BuildValidServiceProvider<FakeLogMessage, ILogMessage>(includeRabbitMqSettings: false);
            var factory = new MonitoringServiceFactory(provider);
            var ex = Assert.Throws<InvalidOperationException>(() => factory.Create(typeof(FakeLogMessage)));
            Assert.Contains("RabbitMqSettings", ex.Message, StringComparison.OrdinalIgnoreCase);
        }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Initialisation\RabbitMqHostedInitialiserTests.cs

using Microsoft.Extensions.Logging;
using Moq;
using RCS.RabbitMq.Consumer.Initialisation;
using RCS.RabbitMq.Consumer.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Initialisation;
public class RabbitMqHostedInitialiserTests
{
    [Fact]
    public async Task StartAsync_Should_Call_Initialiser_And_Log_Info()
    {
        
        var mockLogger = new Mock<ILogger<RabbitMqHostedInitialiser>>();
        var mockInitialiser = new Mock<IRabbitMqInitialiser>();
        var hostedService = new RabbitMqHostedInitialiser(mockInitialiser.Object, mockLogger.Object);
        var token = CancellationToken.None;
        
        await hostedService.StartAsync(token);
        
        mockInitialiser.Verify(i => i.InitialiseExchangeAndQueue(), Times.Once);
        mockLogger.Verify(l => l.Log(
            LogLevel.Information,
            It.IsAny<EventId>(),
            It.Is<It.IsAnyType>((v, _) => v.ToString()!.Contains("Initialising RabbitMQ infrastructure")),
            null,
            It.IsAny<Func<It.IsAnyType, Exception?, string>>()), Times.Once);
        mockLogger.Verify(l => l.Log(
            LogLevel.Information,
            It.IsAny<EventId>(),
            It.Is<It.IsAnyType>((v, _) => v.ToString()!.Contains("RabbitMQ infrastructure initialised")),
            null,
            It.IsAny<Func<It.IsAnyType, Exception?, string>>()), Times.Once);
    }
    [Fact]
    public async Task StopAsync_Should_Complete_Silently()
    {
        
        var mockLogger = new Mock<ILogger<RabbitMqHostedInitialiser>>();
        var mockInitialiser = new Mock<IRabbitMqInitialiser>();
        var hostedService = new RabbitMqHostedInitialiser(mockInitialiser.Object, mockLogger.Object);
        
        await hostedService.StopAsync(CancellationToken.None);
        
        Assert.True(true); 
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Initialisation\RabbitMqInitialiserTests.cs

using Microsoft.Extensions.Logging;
using Moq;
using RabbitMQ.Client;
using RCS.RabbitMq.Consumer.Initialisation;
using RCS.RabbitMq.Consumer.Models;
namespace RCS.RabbitMq.Tests.Consumer.Initialisation
{
    public class RabbitMqInitialiserTests
    {
        [Fact]
        public void InitialiseExchangeAndQueue_Should_Declare_Exchange_And_Queue()
        {
            
            var settings = new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                QueueName = "test.queue",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                RoutingKey = "test",
                RetryQueueTimeToLive = 60000
            };
            var mockLogger = new Mock<ILogger<RabbitMqInitialiser>>();
            var mockChannel = new Mock<IModel>();
            var initialiser = new RabbitMqInitialiser(mockChannel.Object, settings, mockLogger.Object);
            
            initialiser.InitialiseExchangeAndQueue();
            
            mockChannel.Verify(c => c.ExchangeDeclare(
                settings.ExchangeName.ToLower(),
                settings.ExchangeType.ToLower(),
                true,
                false,
                null), Times.Once);
        }
        [Fact]
        public void InitialiseExchangeAndQueue_Should_LogError_And_Rethrow_On_Exception()
        {
            
            var settings = new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                QueueName = "test.queue",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                RoutingKey = "test",
                RetryQueueTimeToLive = 60000
            };
            var mockLogger = new Mock<ILogger<RabbitMqInitialiser>>();
            var mockChannel = new Mock<IModel>();
            
            mockChannel
                .Setup(c => c.ExchangeDeclare(It.IsAny<string>(), It.IsAny<string>(), true, false, null))
                .Throws(new InvalidOperationException("Simulated failure"));
            var initialiser = new RabbitMqInitialiser(mockChannel.Object, settings, mockLogger.Object);
            
            var ex = Assert.Throws<InvalidOperationException>(() => initialiser.InitialiseExchangeAndQueue());
            Assert.Equal("Simulated failure", ex.Message);
            
            mockLogger.Verify(l => l.Log(
                LogLevel.Error,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains("Error during RabbitMQ initialisation")),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()), Times.Once);
        }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Managers\ConsumerManagerTests.cs

using System.Collections.Concurrent;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Moq;
using RabbitMQ.Client;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Shared.Interfaces;
using RCS.RabbitMq.Tests.Consumer.Models;
using RCS.RabbitMq.Tests.Consumer.Utilities;
namespace RCS.RabbitMq.Tests.Consumer.Managers;
public class ConsumerManagerTests
{
    private readonly ConsumerManager<FakeLogMessage, ILogMessage> _manager;
    public ConsumerManagerTests()
    {
        var services = new ServiceCollection();
        services.AddSingleton(new RabbitMqSettings
        {
            ExchangeName = "test.exchange",
            ExchangeType = "direct",
            Host = "localhost",
            Password = "guest",
            QueueName = "test.queue",
            Username = "guest"
        });
        services.AddSingleton(new ConsumerSettings
        {
            BatchSize = 10,
            InactivityTrigger = 1000,
            MaxConsumerCount = 5,
            MinConsumerCount = 1,
            MessageClass = typeof(FakeLogMessage).FullName!,
            MessageInterface = typeof(ILogMessage).FullName!,
            MessageMapper = typeof(FakeMapper).FullName!,
            MessageType = nameof(FakeLogMessage),
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            NonRetryableExceptions = []
        });
        services.AddSingleton(Mock.Of<IDataProcessingManager<FakeLogMessage>>());
        services.AddSingleton(Mock.Of<ILogger<ScalingCommandHandler>>());
        services.AddSingleton(Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(Mock.Of<IConnection>());
        services.AddSingleton(new ConcurrentQueue<Action>());
        var mockMapper = new Mock<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>();
        mockMapper.Setup(m => m.Map(It.IsAny<FakeLogMessage>())).Returns(Mock.Of<ILogMessage>());
        services.AddSingleton(mockMapper.Object);
        var provider = services.BuildServiceProvider();
        _manager = new ConsumerManager<FakeLogMessage, ILogMessage>(
            new ScalingCommandHandler(provider.GetRequiredService<ILogger<ScalingCommandHandler>>()),
            provider,
            provider.GetRequiredService<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
            provider.GetRequiredService<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
        );
    }
    [Fact]
    public void StartConsumer_Should_Not_Throw()
    {
        var token = CancellationToken.None;
        var ex = Record.Exception(() => _manager.StartConsumer(token));
        Assert.Null(ex);
    }
    [Fact]
    public void StopConsumer_Should_Not_Throw()
    {
        var token = CancellationToken.None;
        var ex = Record.Exception(() => _manager.StopConsumer(token));
        Assert.Null(ex);
    }
    [Fact]
    public void ExecuteScalingCommands_Should_Not_Throw_When_Empty()
    {
        var ex = Record.Exception(() => _manager.ExecuteScalingCommands());
        Assert.Null(ex);
    }
    [Fact]
    public void StartConsumer_Should_Enqueue_Command_And_Execute()
    {
        
        var token = CancellationToken.None;
        
        _manager.StartConsumer(token);
        var ex = Record.Exception(() => _manager.ExecuteScalingCommands());
        
        Assert.Null(ex);
    }
    [Fact]
    public void StopConsumer_Should_Remove_Consumer_And_Execute()
    {
        
        var token = CancellationToken.None;
        _manager.StartConsumer(token);
        _manager.ExecuteScalingCommands();
        
        _manager.StopConsumer(token);
        var ex = Record.Exception(() => _manager.ExecuteScalingCommands());
        
        Assert.Null(ex);
    }
    [Fact]
    public void ExecuteScalingCommands_Should_Run_Queued_Actions_Indirectly()
    {
        
        var wasRun = false;
        var services = new ServiceCollection();
        
        var scalingLogger = new Mock<ILogger<ScalingCommandHandler>>();
        var scalingHandler = new ScalingCommandHandler(scalingLogger.Object);
        scalingHandler.AddCommand(() => wasRun = true);
        services.AddSingleton(scalingHandler);
        
        services.AddSingleton(new RabbitMqSettings
        {
            Host = "localhost",
            Username = "guest",
            Password = "guest",
            ExchangeName = "test.exchange",
            ExchangeType = "direct",
            QueueName = "test.queue"
        });
        services.AddSingleton(new ConsumerSettings
        {
            MessageType = nameof(FakeLogMessage),
            MessageInterface = typeof(ILogMessage).FullName!,
            MessageClass = typeof(FakeLogMessage).FullName!,
            MessageMapper = typeof(FakeMapper).FullName!,
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            MinConsumerCount = 1,
            MaxConsumerCount = 5,
            BatchSize = 10,
            InactivityTrigger = 1000,
            NonRetryableExceptions = []
        });
        services.AddSingleton(Mock.Of<IDataProcessingManager<FakeLogMessage>>());
        services.AddSingleton(Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>());
        var provider = services.BuildServiceProvider();
        var manager = new ConsumerManager<FakeLogMessage, ILogMessage>(
            scalingHandler,
            provider,
            provider.GetRequiredService<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
            provider.GetRequiredService<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
        );
        
        manager.ExecuteScalingCommands();
        
        Assert.True(wasRun);
    }
    [Fact]
    public async Task StartAsync_Should_Invoke_StartConsumer()
    {
        
        var logger = new Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>();
        var handler = new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>());
        var mapper = new Mock<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>();
        var services = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, ILogMessage>();
        var manager = new ConsumerManager<FakeLogMessage, ILogMessage>(
            handler,
            services,
            logger.Object,
            mapper.Object);
        
        await manager.StartAsync(CancellationToken.None); 
        
        Assert.True(true);
    }
    [Fact]
    public async Task StopAsync_Should_Invoke_StopConsumer()
    {
        
        var logger = new Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>();
        var handler = new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>());
        var mapper = new Mock<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>();
        var services = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, ILogMessage>();
        var manager = new ConsumerManager<FakeLogMessage, ILogMessage>(
            handler,
            services,
            logger.Object,
            mapper.Object);
        
        await manager.StopAsync(CancellationToken.None); 
        
        Assert.True(true);
    }
    [Fact]
    public void StartConsumer_Should_Log_If_Cancellation_Is_Requested()
    {
        
        var logger = new Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>();
        var cancellationToken = new CancellationToken(true); 
        var manager = BuildManager(logger: logger);
        
        manager.StartConsumer(cancellationToken);
        manager.ExecuteScalingCommands();
        
        logger.Verify(l => l.Log(
            LogLevel.Information,
            It.IsAny<EventId>(),
            It.Is<It.IsAnyType>((v, _) => v.ToString()!.Contains("StartConsumer canceled.")),
            null,
            It.IsAny<Func<It.IsAnyType, Exception?, string>>()
        ), Times.Once);
    }
    [Fact]
    public void StartConsumer_Should_Return_When_ConsumerTag_Is_Null()
    {
        
        var rabbitMqSettings = new RabbitMqSettings
        {
            Host = "localhost",
            Username = "guest",
            Password = "guest",
            ExchangeName = "test.exchange",
            ExchangeType = "direct",
            QueueName = "test.queue",
            RoutingKey = "test",
            MaxRetry = 3,
            RetryQueueTimeToLive = 60000,
            MessageTimeToLive = 300000
        };
        var consumerSettings = new ConsumerSettings
        {
            MessageType = nameof(FakeLogMessage),
            MessageInterface = typeof(ILogMessage).FullName!,
            MessageClass = typeof(FakeLogMessage).FullName!,
            MessageMapper = typeof(FakeMapper).FullName!,
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            MinConsumerCount = 1,
            MaxConsumerCount = 3,
            BatchSize = 10,
            InactivityTrigger = 1000,
            NonRetryableExceptions = []
        };
        var services = new ServiceCollection();
        services.AddSingleton(rabbitMqSettings);
        services.AddSingleton(consumerSettings);
        services.AddSingleton(Mock.Of<IDataProcessingManager<FakeLogMessage>>());
        services.AddSingleton(Mock.Of<ILogger<ScalingCommandHandler>>());
        services.AddSingleton<ScalingCommandHandler>(); 
        services.AddSingleton(Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(Mock.Of<IConnection>());
        services.AddSingleton(new ConcurrentQueue<Action>());
        services.AddSingleton(Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>());
        
        services.AddSingleton<IConsumerService<FakeLogMessage, ILogMessage>, TestConsumerService>();
        services.AddSingleton<ConsumerManager<FakeLogMessage, ILogMessage>>();
        var provider = services.BuildServiceProvider();
        var manager = provider.GetRequiredService<ConsumerManager<FakeLogMessage, ILogMessage>>();
        
        manager.StartConsumer(CancellationToken.None);
        manager.ExecuteScalingCommands();
        
    }
    [Fact]
    public void StartConsumer_Should_Add_Consumer_And_Log_Success()
    {
        
        var logger = new Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>();
        var services = new ServiceCollection();
        services.AddSingleton(new RabbitMqSettings
        {
            Host = "localhost",
            Username = "guest",
            Password = "guest",
            ExchangeName = "test.exchange",
            ExchangeType = "direct",
            QueueName = "test.queue",
            RoutingKey = "test",
            MaxRetry = 3,
            RetryQueueTimeToLive = 60000,
            MessageTimeToLive = 300000
        });
        services.AddSingleton(new ConsumerSettings
        {
            MessageType = "FakeLogMessage",
            MessageInterface = "ILogMessage",
            MessageClass = "FakeLogMessage",
            MessageMapper = "FakeMapper",
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            MinConsumerCount = 1,
            MaxConsumerCount = 3,
            BatchSize = 10,
            InactivityTrigger = 1000,
            NonRetryableExceptions = []
        });
        services.AddSingleton(Mock.Of<IDataProcessingManager<FakeLogMessage>>());
        services.AddSingleton(Mock.Of<ILogger<ScalingCommandHandler>>());
        services.AddSingleton(logger.Object);
        services.AddSingleton(Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(new ConcurrentQueue<Action>());
        
        var mockChannel = new Mock<IModel>();
        var mockConnection = new Mock<IConnection>();
        mockConnection.Setup(c => c.CreateModel()).Returns(mockChannel.Object);
        services.AddSingleton(mockConnection.Object);
        var mockMapper = new Mock<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>();
        mockMapper.Setup(m => m.Map(It.IsAny<FakeLogMessage>())).Returns(Mock.Of<ILogMessage>());
        services.AddSingleton(mockMapper.Object);
        var provider = services.BuildServiceProvider();
        var manager = new ConsumerManager<FakeLogMessage, ILogMessage>(
            new ScalingCommandHandler(provider.GetRequiredService<ILogger<ScalingCommandHandler>>()),
            provider,
            logger.Object,
            provider.GetRequiredService<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
        );
        
        manager.StartConsumer(CancellationToken.None);
        manager.ExecuteScalingCommands();
        
        logger.Verify(l => l.Log(
            LogLevel.Information,
            It.IsAny<EventId>(),
            It.Is<It.IsAnyType>((v, _) => v.ToString()!.Contains("started successfully")),
            null,
            It.IsAny<Func<It.IsAnyType, Exception?, string>>()
        ), Times.AtLeastOnce);
    }
    [Fact]
    public void StartConsumer_Should_Return_If_ConsumerTag_Is_Null()
    {
        
        var services = new ServiceCollection();
        services.AddSingleton(new RabbitMqSettings { Host = "x", Username = "x", Password = "x", ExchangeName = "x", ExchangeType = "direct", QueueName = "x", RoutingKey = "x" });
        services.AddSingleton(new ConsumerSettings
        {
            MessageType = "Fake",
            MessageInterface = "IFake",
            MessageClass = "Fake",
            MessageMapper = "FakeMapper",
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            MinConsumerCount = 1,
            MaxConsumerCount = 1,
            BatchSize = 1,
            InactivityTrigger = 1,
            NonRetryableExceptions = []
        });
        services.AddSingleton(Mock.Of<IDataProcessingManager<FakeLogMessage>>());
        services.AddSingleton(Mock.Of<IConnection>());
        services.AddSingleton(new ConcurrentQueue<Action>());
        services.AddSingleton(Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(Mock.Of<ILogger<ScalingCommandHandler>>());
        services.AddSingleton<ScalingCommandHandler>();
        services.AddSingleton(Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>());
        
        services.AddSingleton<IConsumerService<FakeLogMessage, ILogMessage>, StubConsumerServiceWithFixedTag>();
        services.AddSingleton<ConsumerManager<FakeLogMessage, ILogMessage>>();
        var provider = services.BuildServiceProvider();
        var manager = provider.GetRequiredService<ConsumerManager<FakeLogMessage, ILogMessage>>();
        
        manager.StartConsumer(CancellationToken.None);
        manager.ExecuteScalingCommands();
        
    }
    [Fact]
    public void StartConsumer_Should_Register_If_ConsumerTag_Is_Not_Null()
    {
        
        var services = new ServiceCollection();
        services.AddSingleton(new RabbitMqSettings { Host = "x", Username = "x", Password = "x", ExchangeName = "x", ExchangeType = "direct", QueueName = "x", RoutingKey = "x" });
        services.AddSingleton(new ConsumerSettings
        {
            MessageType = "Fake",
            MessageInterface = "IFake",
            MessageClass = "Fake",
            MessageMapper = "FakeMapper",
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            MinConsumerCount = 1,
            MaxConsumerCount = 1,
            BatchSize = 1,
            InactivityTrigger = 1,
            NonRetryableExceptions = []
        });
        services.AddSingleton(Mock.Of<IDataProcessingManager<FakeLogMessage>>());
        services.AddSingleton(Mock.Of<IConnection>());
        services.AddSingleton(new ConcurrentQueue<Action>());
        services.AddSingleton(Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(Mock.Of<ILogger<ScalingCommandHandler>>());
        services.AddSingleton<ScalingCommandHandler>();
        services.AddSingleton(Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>());
        
        services.AddSingleton<IConsumerService<FakeLogMessage, ILogMessage>, StubConsumerServiceWithFixedTagReturningNonNull>();
        services.AddSingleton<ConsumerManager<FakeLogMessage, ILogMessage>>();
        var provider = services.BuildServiceProvider();
        var manager = provider.GetRequiredService<ConsumerManager<FakeLogMessage, ILogMessage>>();
        
        manager.StartConsumer(CancellationToken.None);
        manager.ExecuteScalingCommands();
        
    }
    [Fact]
    public void Constructor_Should_Log_Scaling_Timer_Started()
    {
        
        var logger = new Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>();
        var services = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, ILogMessage>();
        
        var _ = new ConsumerManager<FakeLogMessage, ILogMessage>(
            new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
            services,
            logger.Object,
            Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>());
        
        logger.Verify(l => l.Log(
            LogLevel.Information,
            It.IsAny<EventId>(),
            It.Is<It.IsAnyType>((v, _) => v.ToString()!.Contains("scaling timer started")),
            null,
            It.IsAny<Func<It.IsAnyType, Exception?, string>>()), Times.Once);
    }
    [Fact]
    public void Constructor_Should_Initialize_And_Log_Timer_Start()
    {
        
        var logger = new Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>();
        var serviceProvider = TestHelper.BuildValidConsumerServiceProvider<FakeLogMessage, ILogMessage>();
        var scalingHandler = new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>());
        var mapper = new Mock<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>();
        
        var _ = new ConsumerManager<FakeLogMessage, ILogMessage>(
            scalingHandler,
            serviceProvider,
            logger.Object,
            mapper.Object
        );
        
        logger.Verify(l => l.Log(
                LogLevel.Information,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((o, t) => o.ToString()!.Contains("scaling timer started")),
                null,
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Once);
    }
    private ConsumerManager<FakeLogMessage, ILogMessage> BuildManager(Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>? logger = null)
    {
        var services = new ServiceCollection();
        services.AddSingleton(new RabbitMqSettings
        {
            Host = "localhost",
            Username = "guest",
            Password = "guest",
            ExchangeName = "test.exchange",
            ExchangeType = "direct",
            QueueName = "test.queue",
            RoutingKey = "test",
            MaxRetry = 3,
            RetryQueueTimeToLive = 60000,
            MessageTimeToLive = 300000
        });
        services.AddSingleton(new ConsumerSettings
        {
            MessageType = "FakeLogMessage",
            MessageInterface = "ILogMessage",
            MessageClass = "FakeLogMessage",
            MessageMapper = "FakeMapper",
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            MinConsumerCount = 1,
            MaxConsumerCount = 3,
            BatchSize = 10,
            InactivityTrigger = 1000,
            NonRetryableExceptions = []
        });
        services.AddSingleton(Mock.Of<IDataProcessingManager<FakeLogMessage>>());
        services.AddSingleton(Mock.Of<ILogger<ScalingCommandHandler>>());
        services.AddSingleton(logger?.Object ?? Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(Mock.Of<IConnection>());
        services.AddSingleton(new ConcurrentQueue<Action>());
        services.AddSingleton(Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>());
        var mockMapper = new Mock<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>();
        mockMapper.Setup(m => m.Map(It.IsAny<FakeLogMessage>())).Returns(Mock.Of<ILogMessage>());
        services.AddSingleton(mockMapper.Object);
        var provider = services.BuildServiceProvider();
        return new ConsumerManager<FakeLogMessage, ILogMessage>(
            new ScalingCommandHandler(provider.GetRequiredService<ILogger<ScalingCommandHandler>>()),
            provider,
            provider.GetRequiredService<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
            provider.GetRequiredService<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>());
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Managers\ScalingCommandHandlerTests.cs

using Microsoft.Extensions.Logging;
using Moq;
using RCS.RabbitMq.Consumer.Managers;
namespace RCS.RabbitMq.Tests.Consumer.Managers;
public class ScalingCommandHandlerTests
{
    [Fact]
    public void AddCommand_Should_Store_And_Execute_Command()
    {
        
        var logger = new Mock<ILogger<ScalingCommandHandler>>();
        var handler = new ScalingCommandHandler(logger.Object);
        var wasExecuted = false;
        
        handler.AddCommand(() => wasExecuted = true);
        handler.ExecuteCommands();
        
        Assert.True(wasExecuted);
    }
    [Fact]
    public void ExecuteCommands_Should_Run_All_Actions()
    {
        
        var logger = new Mock<ILogger<ScalingCommandHandler>>();
        var handler = new ScalingCommandHandler(logger.Object);
        var executed1 = false;
        var executed2 = false;
        handler.AddCommand(() => executed1 = true);
        handler.AddCommand(() => executed2 = true);
        
        handler.ExecuteCommands();
        
        Assert.True(executed1);
        Assert.True(executed2);
    }
    [Fact]
    public void ExecuteCommands_Should_Continue_After_Exception()
    {
        
        var logger = new Mock<ILogger<ScalingCommandHandler>>();
        var handler = new ScalingCommandHandler(logger.Object);
        var executed = false;
        handler.AddCommand(() => throw new Exception("bang"));
        handler.AddCommand(() => executed = true);
        
        handler.ExecuteCommands();
        
        Assert.True(executed);
    }
    [Fact]
    public void ExecuteScalingCommands_Should_Run_Queued_Actions()
    {
        
        var logger = new Mock<ILogger<ScalingCommandHandler>>();
        var handler = new ScalingCommandHandler(logger.Object);
        var executed = false;
        handler.AddCommand(() => executed = true);
        
        handler.ExecuteCommands();
        
        Assert.True(executed, "Expected the queued action to be executed.");
    }
    [Fact]
    public void StripGeneratedPart_Should_Return_MethodName_When_No_Generics()
    {
        
        var logger = new Mock<ILogger<ScalingCommandHandler>>();
        var handler = new ScalingCommandHandler(logger.Object);
        
        handler.AddCommand(NamedPlainMethod);
        handler.ExecuteCommands();
        
        logger.Verify(l => l.Log(
            LogLevel.Information,
            It.IsAny<EventId>(),
            It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains("NamedPlainMethod")),
            null,
            It.IsAny<Func<It.IsAnyType, Exception?, string>>()), Times.AtLeastOnce);
    }
    private static void NamedPlainMethod()
    {
        
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Models\FakeContract.cs

using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Models;
public class FakeContract : IBasicMessageContract
{
    public ulong DeliveryTag { get; set; }
    public IDictionary<string, object>? Headers { get; set; } = new Dictionary<string, object>();
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Models\FakeLogMessage.cs

using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Logging.Processor.Models;
namespace RCS.RabbitMq.Tests.Consumer.Models;
public class FakeLogMessage : LogMessage, ILogMessage;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Models\FakeMapper.cs

using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Models;
public class FakeMapper : IRabbitMessageMapper<FakeMessage, FakeContract>
{
    public FakeContract Map(FakeMessage _) => new();
    public static FakeContract ToContract(FakeMessage _) => new();
    public static FakeMessage ToMessage(FakeContract _) => new();
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Models\FakeMessage.cs

using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Models;
public class FakeMessage : IAcknowledgeableRabbitMessage
{
    public ulong DeliveryTag { get; set; }
    public IDictionary<string, object>? Headers { get; set; } = new Dictionary<string, object>();
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Models\FakeWhatsAppMessage.cs

using RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Interfaces;
using RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Models;
namespace RCS.RabbitMq.Tests.Consumer.Models
{
    public class FakeWhatsAppMessage : WhatsAppMessage, IWhatsAppMessage { }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs


using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\obj\Debug\net8.0\RabbitMq.Consumer.Tests.AssemblyInfo.cs










using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("RabbitMq.Consumer.Tests")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+7ab39a14ee66e0e44771d5cf6f5720aecb245dd8")]
[assembly: System.Reflection.AssemblyProductAttribute("RabbitMq.Consumer.Tests")]
[assembly: System.Reflection.AssemblyTitleAttribute("RabbitMq.Consumer.Tests")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\obj\Debug\net8.0\RabbitMq.Consumer.Tests.GlobalUsings.g.cs


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
global using global::Xunit;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\obj\Debug\net8.0\RCS.RabbitMq.Consumer.Tests.AssemblyInfo.cs










using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("RCS.RabbitMq.Consumer.Tests")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("RCS.RabbitMq.Consumer.Tests")]
[assembly: System.Reflection.AssemblyTitleAttribute("RCS.RabbitMq.Consumer.Tests")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\obj\Debug\net8.0\RCS.RabbitMq.Consumer.Tests.GlobalUsings.g.cs


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
global using global::Xunit;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\obj\Debug\net8.0\RCS.RabbitMq.Tests.Consumer.AssemblyInfo.cs










using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("RCS.RabbitMq.Tests.Consumer")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("RCS.RabbitMq.Tests.Consumer")]
[assembly: System.Reflection.AssemblyTitleAttribute("RCS.RabbitMq.Tests.Consumer")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\obj\Debug\net8.0\RCS.RabbitMq.Tests.Consumer.GlobalUsings.g.cs


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
global using global::Xunit;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\obj\Debug\net9.0\RabbitMq.Consumer.Tests.GlobalUsings.g.cs


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
global using global::Xunit;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Services\ConsumerServiceTests.cs

using System.Collections.Concurrent;
using System.Reflection;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Moq;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Shared.Interfaces;
using RCS.RabbitMq.Tests.Consumer.Models;
using RCS.RabbitMq.Tests.Consumer.Utilities;
namespace RCS.RabbitMq.Tests.Consumer.Services;
public class ConsumerServiceTests
{
    [Fact]
    public void StartConsuming_Should_Start_Without_Exception()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var settings = new RabbitMqSettings
        {
            Host = "localhost",
            Username = "guest",
            Password = "guest",
            QueueName = "test.queue",
            ExchangeName = "test.exchange",
            ExchangeType = "direct"
        };
        var consumerSettings = new ConsumerSettings
        {
            BatchSize = 10,
            InactivityTrigger = 1000,
            MaxConsumerCount = 5,
            MinConsumerCount = 1,
            MessageClass = typeof(FakeLogMessage).FullName!,
            MessageInterface = typeof(ILogMessage).FullName!,
            MessageMapper = typeof(FakeMapper).FullName!,
            MessageType = nameof(FakeLogMessage),
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            NonRetryableExceptions = []
        };
        var queue = new ConcurrentQueue<Action>();
        var mockLogger = new Mock<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>();
        var mockConnection = new Mock<IConnection>();
        var mockChannel = new Mock<IModel>();
        mockConnection.Setup(c => c.CreateModel()).Returns(mockChannel.Object);
        var scalingHandler = new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>());
        var mockConsumerLogger = new Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>();
        var mockMapper = new Mock<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>();
        var consumerManager = new ConsumerManager<FakeLogMessage, ILogMessage>(
            scalingHandler,
            new ServiceCollection().BuildServiceProvider(),
            mockConsumerLogger.Object,
            mockMapper.Object
        );
        var service = new ConsumerService<FakeLogMessage, ILogMessage>(
            mockProcessor.Object,
            settings,
            consumerSettings,
            queue,
            mockLogger.Object,
            mockConnection.Object,
            consumerManager
        );
        
        var tag = service.StartConsuming(CancellationToken.None);
        
        Assert.NotNull(tag);
    }
    [Fact]
    public void StopConsuming_Should_Stop_Without_Exception()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var settings = new RabbitMqSettings
        {
            Host = "localhost",
            Username = "guest",
            Password = "guest",
            QueueName = "test.queue",
            ExchangeName = "test.exchange",
            ExchangeType = "direct"
        };
        var consumerSettings = new ConsumerSettings
        {
            BatchSize = 10,
            InactivityTrigger = 1000,
            MaxConsumerCount = 5,
            MinConsumerCount = 1,
            MessageClass = typeof(FakeLogMessage).FullName!,
            MessageInterface = typeof(ILogMessage).FullName!,
            MessageMapper = typeof(FakeMapper).FullName!,
            MessageType = nameof(FakeLogMessage),
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            NonRetryableExceptions = []
        };
        var queue = new ConcurrentQueue<Action>();
        var mockLogger = new Mock<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>();
        var mockConnection = new Mock<IConnection>();
        var mockChannel = new Mock<IModel>();
        mockConnection.Setup(c => c.CreateModel()).Returns(mockChannel.Object);
        var scalingHandler = new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>());
        var mockConsumerLogger = new Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>();
        var mockMapper = new Mock<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>();
        var consumerManager = new ConsumerManager<FakeLogMessage, ILogMessage>(
            scalingHandler,
            new ServiceCollection().BuildServiceProvider(),
            mockConsumerLogger.Object,
            mockMapper.Object
        );
        var service = new ConsumerService<FakeLogMessage, ILogMessage>(
            mockProcessor.Object,
            settings,
            consumerSettings,
            queue,
            mockLogger.Object,
            mockConnection.Object,
            consumerManager
        );
        service.StartConsuming(CancellationToken.None);
        
        service.StopConsuming(CancellationToken.None);
        
        
        Assert.True(true);
    }
    [Fact]
    public async Task HandleMessageAsync_Should_Process_Message()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var message = new FakeLogMessage();
        var mockLogger = new Mock<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>();
        var mockConnection = new Mock<IConnection>();
        var mockChannel = new Mock<IModel>();
        mockConnection.Setup(c => c.CreateModel()).Returns(mockChannel.Object);
        var consumerManager = new ConsumerManager<FakeLogMessage, ILogMessage>(
            new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
            new ServiceCollection().BuildServiceProvider(),
            Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
        );
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue"
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            mockLogger.Object,
            mockConnection.Object,
            consumerManager
        );
        var cancellationToken = CancellationToken.None;
        
        await service.InvokeHandleMessageAsync(message, cancellationToken);
        
        mockProcessor.Verify(p => p.ProcessBatchAsync(It.Is<IEnumerable<FakeLogMessage>>(msgs => msgs.Contains(message))), Times.Once);
    }
    [Fact]
    public async Task ProcessBatchAsync_Should_Call_DataProcessingManager()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var messages = new List<FakeLogMessage> { new() };
        mockProcessor.Setup(p => p.ProcessBatchAsync(messages)).ReturnsAsync(true);
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue"
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        
        var result = await service.InvokeProcessBatchAsync(messages);
        
        Assert.True(result);
        mockProcessor.Verify(p => p.ProcessBatchAsync(messages), Times.Once);
    }
    [Fact]
    public async Task PrepareBatchAsync_Should_Ack_On_Success()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var message = new FakeLogMessage { DeliveryTag = 1 };
        mockProcessor.Setup(p => p.ProcessBatchAsync(It.IsAny<IEnumerable<FakeLogMessage>>()))
                     .ReturnsAsync(true);
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings { Host = "localhost", Username = "guest", Password = "guest", ExchangeName = "test.exchange", ExchangeType = "direct", QueueName = "test.queue", RoutingKey = "test.key" },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var queue = new ConcurrentQueue<FakeLogMessage>();
        queue.Enqueue(message);
        var deliveryTags = new ConcurrentDictionary<ulong, byte>();
        deliveryTags.TryAdd(1, 0);
        
        await service.InvokePrepareBatchAsync(queue, deliveryTags, mockChannel.Object);
        
        mockChannel.Verify(c => c.BasicAck(1, true), Times.Once);
    }
    [Fact]
    public async Task PrepareBatchAsync_Should_Nack_On_Exception()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var message = new FakeLogMessage { DeliveryTag = 2 };
        mockProcessor.Setup(p => p.ProcessBatchAsync(It.IsAny<IEnumerable<FakeLogMessage>>()))
                     .ThrowsAsync(new Exception("Simulated failure"));
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings { Host = "localhost", Username = "guest", Password = "guest", ExchangeName = "test.exchange", ExchangeType = "direct", QueueName = "test.queue", RoutingKey = "test.key" },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var queue = new ConcurrentQueue<FakeLogMessage>();
        queue.Enqueue(message);
        var deliveryTags = new ConcurrentDictionary<ulong, byte>();
        deliveryTags.TryAdd(2, 0);
        
        await service.InvokePrepareBatchAsync(queue, deliveryTags, mockChannel.Object);
        
        mockChannel.Verify(c => c.BasicNack(2, false, false), Times.Once);
    }
    [Fact]
    public async Task RetryOrDeadLetter_Should_Retry_If_Under_MaxRetry()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var message = new FakeLogMessage
        {
            DeliveryTag = 1,
            Headers = new Dictionary<string, object>
            {
                ["x-death"] = new List<object>
            {
                new Dictionary<string, object>
                {
                    ["count"] = (long)2
                }
            }
            }
        };
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key",
                MaxRetry = 5
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        
        var method = typeof(ConsumerService<FakeLogMessage, ILogMessage>)
            .GetMethod("RetryOrDeadLetter", BindingFlags.NonPublic | BindingFlags.Instance);
        var task = (Task?)method!.Invoke(service, [message, mockChannel.Object]);
        if (task != null)
            await task;
        
        mockChannel.Verify(c => c.BasicAck(1, false), Times.Once);
    }
    [Fact]
    public async Task MoveToDeadLetterQueue_Should_Publish_And_Ack_Message()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var message = new FakeLogMessage { DeliveryTag = 10 };
        var mockProps = new Mock<IBasicProperties>();
        mockChannel.Setup(c => c.CreateBasicProperties()).Returns(mockProps.Object);
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key"
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var method = typeof(ConsumerService<FakeLogMessage, ILogMessage>)
            .GetMethod("MoveToDeadLetterQueue", BindingFlags.NonPublic | BindingFlags.Instance);
        
        var task = (Task?)method!.Invoke(service, [message, mockChannel.Object]);
        if (task != null)
            await task;
        
        mockChannel.Verify(c => c.BasicAck(10, false), Times.Once);
        Assert.Contains(mockChannel.Invocations, invocation =>
            invocation.Method.Name == "BasicPublish" &&
            invocation.Arguments[0].Equals("test.exchange") &&
            invocation.Arguments[1].Equals("test.key_dead")
        );
    }
    [Fact]
    public async Task RequeueMessage_Should_Ack_And_Publish_To_Retry_Queue()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var message = new FakeLogMessage
        {
            DeliveryTag = 20,
            Headers = new Dictionary<string, object> { { "test", "value" } }
        };
        var mockProps = new Mock<IBasicProperties>();
        mockChannel.Setup(c => c.CreateBasicProperties()).Returns(mockProps.Object);
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key"
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var method = typeof(ConsumerService<FakeLogMessage, ILogMessage>)
            .GetMethod("RequeueMessage", BindingFlags.NonPublic | BindingFlags.Instance);
        
        var task = (Task?)method!.Invoke(service, [message, mockChannel.Object]);
        if (task != null)
            await task;
        
        mockChannel.Verify(c => c.BasicAck(20, false), Times.Once);
        Assert.Contains(mockChannel.Invocations, invocation =>
            invocation.Method.Name == "BasicPublish" &&
            invocation.Arguments[0].Equals("test.exchange") &&
            invocation.Arguments[1].Equals("test.key_retry")
        );
    }
    [Fact]
    public async Task HandleError_Should_Invoke_RetryOrDeadLetter_For_TimeoutException()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var mockProps = new Mock<IBasicProperties>();
        var publishCalled = false;
        var message = new FakeLogMessage
        {
            DeliveryTag = 99,
            Headers = new Dictionary<string, object>
            {
                ["x-death"] = new List<object>
            {
                new Dictionary<string, object>
                {
                    ["count"] = (long)1
                }
            }
            }
        };
        mockChannel.Setup(c => c.CreateBasicProperties()).Returns(mockProps.Object);
        
        mockChannel
            .As<IModel>()
            .Object
            .BasicPublish("test.exchange", "test.key_retry", mockProps.Object, ReadOnlyMemory<byte>.Empty); 
        
        var spyChannel = new SpyChannel(() => publishCalled = true);
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key",
                MaxRetry = 3
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var method = typeof(ConsumerService<FakeLogMessage, ILogMessage>)
            .GetMethod("HandleError", BindingFlags.NonPublic | BindingFlags.Instance);
        var exception = new TimeoutException("Simulated timeout");
        
        var task = (Task?)method!.Invoke(service, [message, exception, spyChannel]);
        if (task != null)
            await task;
        
        Assert.True(spyChannel.AckCalled, "Expected BasicAck to be called.");
        Assert.True(publishCalled, "Expected BasicPublish to be called.");
    }
    [Fact]
    public async Task ConsumerService_EndToEnd_Should_Process_And_Ack_Message()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var mockLogger = new Mock<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>();
        var message = new FakeLogMessage
        {
            DeliveryTag = 42,
            Headers = new Dictionary<string, object>()
        };
        mockProcessor
            .Setup(p => p.ProcessBatchAsync(It.IsAny<IEnumerable<FakeLogMessage>>()))
            .ReturnsAsync(true);
        var acked = false;
        mockChannel.Setup(c => c.BasicAck(42, true)).Callback(() => acked = true);
        mockChannel.Setup(c => c.CreateBasicProperties()).Returns(new Mock<IBasicProperties>().Object);
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key"
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            mockLogger.Object,
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var queue = new ConcurrentQueue<FakeLogMessage>();
        queue.Enqueue(message);
        var deliveryTags = new ConcurrentDictionary<ulong, byte>();
        deliveryTags.TryAdd(42, 0);
        
        await service.InvokePrepareBatchAsync(queue, deliveryTags, mockChannel.Object);
        
        mockProcessor.Verify(p => p.ProcessBatchAsync(It.Is<IEnumerable<FakeLogMessage>>(m => m.Contains(message))), Times.Once);
        Assert.True(acked, "Expected BasicAck to be called.");
    }
    [Fact]
    public async Task ConsumerService_EndToEnd_Should_Nack_On_Process_Failure()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var message = new FakeLogMessage { DeliveryTag = 43 };
        mockProcessor
            .Setup(p => p.ProcessBatchAsync(It.IsAny<IEnumerable<FakeLogMessage>>()))
            .ThrowsAsync(new Exception("Simulated failure"));
        mockChannel.Setup(c => c.BasicNack(43, false, false)).Verifiable();
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key"
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var queue = new ConcurrentQueue<FakeLogMessage>();
        queue.Enqueue(message);
        var deliveryTags = new ConcurrentDictionary<ulong, byte>();
        deliveryTags.TryAdd(43, 0);
        
        await service.InvokePrepareBatchAsync(queue, deliveryTags, mockChannel.Object);
        
        mockChannel.Verify(c => c.BasicNack(43, false, false), Times.Once);
    }
    [Fact]
    public async Task ConsumerService_Should_DeadLetter_When_Base_Exception_Is_Configured_As_NonRetryable()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var mockProps = new Mock<IBasicProperties>();
        var message = new FakeLogMessage { DeliveryTag = 99 };
        mockProcessor
            .Setup(p => p.ProcessBatchAsync(It.IsAny<IEnumerable<FakeLogMessage>>()))
            .ThrowsAsync(new Exception("Non-retryable error"));
        mockChannel.Setup(c => c.CreateBasicProperties()).Returns(mockProps.Object);
        mockChannel.Setup(c => c.BasicAck(99, false)).Verifiable();
        mockChannel.Setup(c => c.BasicPublish(
            "test.exchange",
            "test.key_dead",
            false,
            It.IsAny<IBasicProperties>(),
            It.IsAny<ReadOnlyMemory<byte>>()
        )).Verifiable();
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key"
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = [typeof(Exception).FullName!]
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var queue = new ConcurrentQueue<FakeLogMessage>();
        queue.Enqueue(message);
        var deliveryTags = new ConcurrentDictionary<ulong, byte>();
        deliveryTags.TryAdd(99, 0);
        
        await service.InvokePrepareBatchAsync(queue, deliveryTags, mockChannel.Object);
        
        mockChannel.Verify(c => c.BasicAck(99, false), Times.Once);
        mockChannel.Verify(c => c.BasicPublish(
            "test.exchange",
            "test.key_dead",
            false,
            It.IsAny<IBasicProperties>(),
            It.IsAny<ReadOnlyMemory<byte>>()
        ), Times.Once);
    }
    [Fact]
    public async Task ConsumerService_EndToEnd_Should_Requeue_On_Retryable_Exception()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var mockProps = new Mock<IBasicProperties>();
        var message = new FakeLogMessage
        {
            DeliveryTag = 77,
            Headers = new Dictionary<string, object>
            {
                ["x-death"] = new List<object>
            {
                new Dictionary<string, object>
                {
                    ["count"] = (long)1
                }
            }
            }
        };
        mockProcessor
            .Setup(p => p.ProcessBatchAsync(It.IsAny<IEnumerable<FakeLogMessage>>()))
            .ThrowsAsync(new TimeoutException("Retryable failure"));
        mockChannel.Setup(c => c.CreateBasicProperties()).Returns(mockProps.Object);
        mockChannel.Setup(c => c.BasicAck(77, false)).Verifiable();
        mockChannel.Setup(c => c.BasicPublish(
            "test.exchange",
            "test.key_retry",
            false,
            It.IsAny<IBasicProperties>(),
            It.IsAny<ReadOnlyMemory<byte>>()
        )).Verifiable();
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key",
                MaxRetry = 3
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var queue = new ConcurrentQueue<FakeLogMessage>();
        queue.Enqueue(message);
        var deliveryTags = new ConcurrentDictionary<ulong, byte>();
        deliveryTags.TryAdd(77, 0);
        
        await service.InvokePrepareBatchAsync(queue, deliveryTags, mockChannel.Object);
        
        mockChannel.Verify(c => c.BasicAck(77, false), Times.Once);
        mockChannel.Verify(c => c.BasicPublish(
            "test.exchange",
            "test.key_retry",
            false,
            It.IsAny<IBasicProperties>(),
            It.IsAny<ReadOnlyMemory<byte>>()
        ), Times.Once);
    }
    [Fact]
    public async Task ConsumerService_EndToEnd_Should_DeadLetter_When_Retry_Limit_Exceeded()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var mockProps = new Mock<IBasicProperties>();
        var message = new FakeLogMessage
        {
            DeliveryTag = 88,
            Headers = new Dictionary<string, object>
            {
                ["x-death"] = new List<object>
            {
                new Dictionary<string, object>
                {
                    ["count"] = (long)5
                }
            }
            }
        };
        mockProcessor
            .Setup(p => p.ProcessBatchAsync(It.IsAny<IEnumerable<FakeLogMessage>>()))
            .ThrowsAsync(new TimeoutException("Simulated retryable failure"));
        mockChannel.Setup(c => c.CreateBasicProperties()).Returns(mockProps.Object);
        mockChannel.Setup(c => c.BasicAck(88, false)).Verifiable();
        mockChannel.Setup(c => c.BasicPublish(
            "test.exchange",
            "test.key_dead",
            false,
            It.IsAny<IBasicProperties>(),
            It.IsAny<ReadOnlyMemory<byte>>()
        )).Verifiable();
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key",
                MaxRetry = 3
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = []
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var queue = new ConcurrentQueue<FakeLogMessage>();
        queue.Enqueue(message);
        var deliveryTags = new ConcurrentDictionary<ulong, byte>();
        deliveryTags.TryAdd(88, 0);
        
        await service.InvokePrepareBatchAsync(queue, deliveryTags, mockChannel.Object);
        
        mockChannel.Verify(c => c.BasicAck(88, false), Times.Once);
        mockChannel.Verify(c => c.BasicPublish("test.exchange", "test.key_dead", false,
            It.IsAny<IBasicProperties>(), It.IsAny<ReadOnlyMemory<byte>>()), Times.Once);
    }
    [Fact]
    public async Task ConsumerService_Should_DeadLetter_When_Explicit_NonRetryable_Exception_Is_Thrown()
    {
        
        var mockProcessor = new Mock<IDataProcessingManager<FakeLogMessage>>();
        var mockChannel = new Mock<IModel>();
        var mockProps = new Mock<IBasicProperties>();
        var message = new FakeLogMessage
        {
            DeliveryTag = 99,
            Headers = new Dictionary<string, object>() 
        };
        mockProcessor
            .Setup(p => p.ProcessBatchAsync(It.IsAny<IEnumerable<FakeLogMessage>>()))
            .ThrowsAsync(new InvalidOperationException("Non-retryable"));
        mockChannel.Setup(c => c.CreateBasicProperties()).Returns(mockProps.Object);
        mockChannel.Setup(c => c.BasicAck(99, false)).Verifiable();
        mockChannel.Setup(c => c.BasicPublish(
            "test.exchange",
            "test.key_dead",
            false,
            It.IsAny<IBasicProperties>(),
            It.IsAny<ReadOnlyMemory<byte>>()
        )).Verifiable();
        var service = new TestableConsumerService(
            mockProcessor.Object,
            new RabbitMqSettings
            {
                Host = "localhost",
                Username = "guest",
                Password = "guest",
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                QueueName = "test.queue",
                RoutingKey = "test.key",
                MaxRetry = 3
            },
            new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(FakeLogMessage).FullName!,
                MessageInterface = typeof(ILogMessage).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = nameof(FakeLogMessage),
                ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
                ProcessorClass = typeof(FakeLogMessage).FullName!,
                NonRetryableExceptions = [typeof(InvalidOperationException).FullName!]
            },
            new ConcurrentQueue<Action>(),
            Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            Mock.Of<IConnection>(),
            new ConsumerManager<FakeLogMessage, ILogMessage>(
                new ScalingCommandHandler(Mock.Of<ILogger<ScalingCommandHandler>>()),
                new ServiceCollection().BuildServiceProvider(),
                Mock.Of<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>(),
                Mock.Of<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>()
            )
        );
        var queue = new ConcurrentQueue<FakeLogMessage>();
        queue.Enqueue(message);
        var deliveryTags = new ConcurrentDictionary<ulong, byte>();
        deliveryTags.TryAdd(99, 0);
        
        await service.InvokePrepareBatchAsync(queue, deliveryTags, mockChannel.Object);
        
        mockChannel.Verify(c => c.BasicAck(99, false), Times.Once);
        mockChannel.Verify(c => c.BasicPublish("test.exchange", "test.key_dead", false,
            It.IsAny<IBasicProperties>(), It.IsAny<ReadOnlyMemory<byte>>()), Times.Once);
    }
    [Fact]
    public void StartConsumer_Should_Log_Warning_If_Already_Registered()
    {
        
        var logger = new Mock<ILogger<ConsumerManager<FakeLogMessage, ILogMessage>>>();
        var services = new ServiceCollection();
        services.AddSingleton(new RabbitMqSettings
        {
            Host = "x",
            Username = "x",
            Password = "x",
            ExchangeName = "x",
            ExchangeType = "direct",
            QueueName = "x",
            RoutingKey = "x"
        });
        services.AddSingleton(new ConsumerSettings
        {
            MessageType = "FakeLogMessage",
            MessageInterface = "ILogMessage",
            MessageClass = "FakeLogMessage",
            MessageMapper = "FakeMapper",
            ProcessorAssembly = typeof(FakeLogMessage).Assembly.FullName!,
            ProcessorClass = typeof(FakeLogMessage).FullName!,
            MinConsumerCount = 1,
            MaxConsumerCount = 1,
            BatchSize = 1,
            InactivityTrigger = 1,
            NonRetryableExceptions = []
        });
        services.AddSingleton(Mock.Of<IDataProcessingManager<FakeLogMessage>>());
        services.AddSingleton(new ConcurrentQueue<Action>());
        services.AddSingleton(Mock.Of<ILogger<ScalingCommandHandler>>());
        services.AddSingleton(Mock.Of<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>());
        services.AddSingleton(logger.Object);
        services.AddSingleton<ScalingCommandHandler>();
        var mockMapper = new Mock<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>();
        mockMapper.Setup(m => m.Map(It.IsAny<FakeLogMessage>())).Returns(Mock.Of<ILogMessage>());
        services.AddSingleton(mockMapper.Object);
        
        var mockModel = new Mock<IModel>();
        var mockConnection = new Mock<IConnection>();
        mockConnection.Setup(c => c.CreateModel()).Returns(mockModel.Object);
        services.AddSingleton(mockConnection.Object);
        
        services.AddSingleton<ConsumerManager<FakeLogMessage, ILogMessage>>();
        var provider = services.BuildServiceProvider();
        
        var fixedTag = "fixed-tag";
        var stubService = new StubConsumerServiceWithFixedTag(provider, fixedTag);
        var testManager = new TestableConsumerManager(
            provider.GetRequiredService<ScalingCommandHandler>(),
            provider,
            logger.Object,
            provider.GetRequiredService<IRabbitMessageMapper<FakeLogMessage, ILogMessage>>(),
            stubService
        );
        
        var consumerDict = new ConcurrentDictionary<string, ConsumerService<FakeLogMessage, ILogMessage>>();
        consumerDict.TryAdd(fixedTag, stubService);
        typeof(ConsumerManager<FakeLogMessage, ILogMessage>)
            .GetField("_activeConsumers", BindingFlags.NonPublic | BindingFlags.Instance)!
            .SetValue(testManager, consumerDict);
        
        testManager.StartConsumer(CancellationToken.None);
        testManager.ExecuteScalingCommands();
        
        logger.Verify(l => l.Log(
            LogLevel.Warning,
            It.IsAny<EventId>(),
            It.Is<It.IsAnyType>((v, _) => v.ToString()!.Contains("already registered")),
            null,
            It.IsAny<Func<It.IsAnyType, Exception?, string>>()), Times.Once);
    }
    private class SpyChannel(Action onPublish) : IModel
    {
        public bool AckCalled { get; private set; }
        public IBasicProperties CreateBasicProperties() => new Mock<IBasicProperties>().Object;
        public void BasicAck(ulong deliveryTag, bool multiple)
        {
            AckCalled = true;
        }
        public void BasicPublish(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, ReadOnlyMemory<byte> body)
        {
            onPublish();
        }
        
        public void Dispose() { }
        public void Abort() { }
        public void Abort(ushort replyCode, string replyText) { }
        public void BasicCancel(string consumerTag) { }
        public void BasicCancelNoWait(string consumerTag) { }
        public string BasicConsume(string queue, bool autoAck, string consumerTag, bool noLocal, bool exclusive, IDictionary<string, object> arguments, IBasicConsumer consumer) => "";
        public BasicGetResult BasicGet(string queue, bool autoAck) => null!;
        public void BasicNack(ulong deliveryTag, bool multiple, bool requeue) { }
        public void BasicQos(uint prefetchSize, ushort prefetchCount, bool global) { }
        public void BasicRecover(bool requeue) { }
        public void BasicRecoverAsync(bool requeue) { }
        public void BasicReject(ulong deliveryTag, bool requeue) { }
        public void Close() { }
        public void Close(ushort replyCode, string replyText) { }
        public void ConfirmSelect() { }
        public IBasicPublishBatch CreateBasicPublishBatch() => null!;
        public void ExchangeBind(string destination, string source, string routingKey, IDictionary<string, object> arguments) { }
        public void ExchangeBindNoWait(string destination, string source, string routingKey, IDictionary<string, object> arguments) { }
        public void ExchangeDeclare(string exchange, string type, bool durable, bool autoDelete, IDictionary<string, object> arguments) { }
        public void ExchangeDeclareNoWait(string exchange, string type, bool durable, bool autoDelete, IDictionary<string, object> arguments) { }
        public void ExchangeDeclarePassive(string exchange) { }
        public void ExchangeDelete(string exchange, bool ifUnused) { }
        public void ExchangeDeleteNoWait(string exchange, bool ifUnused) { }
        public void ExchangeUnbind(string destination, string source, string routingKey, IDictionary<string, object> arguments) { }
        public void ExchangeUnbindNoWait(string destination, string source, string routingKey, IDictionary<string, object> arguments) { }
        public void QueueBind(string queue, string exchange, string routingKey, IDictionary<string, object> arguments) { }
        public void QueueBindNoWait(string queue, string exchange, string routingKey, IDictionary<string, object> arguments) { }
        public QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary<string, object> arguments) => null!;
        public void QueueDeclareNoWait(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary<string, object> arguments) { }
        public QueueDeclareOk QueueDeclarePassive(string queue) => null!;
        public uint MessageCount(string queue) => 0;
        public uint ConsumerCount(string queue) => 0;
        public uint QueueDelete(string queue, bool ifUnused, bool ifEmpty) => 0;
        public void QueueDeleteNoWait(string queue, bool ifUnused, bool ifEmpty) { }
        public uint QueuePurge(string queue) => 0;
        public void QueueUnbind(string queue, string exchange, string routingKey, IDictionary<string, object> arguments) { }
        public void TxCommit() { }
        public void TxRollback() { }
        public void TxSelect() { }
        public bool WaitForConfirms() => true;
        public bool WaitForConfirms(TimeSpan timeout) => true;
        public bool WaitForConfirms(TimeSpan timeout, out bool timedOut) { timedOut = false; return true; }
        public void WaitForConfirmsOrDie() { }
        public void WaitForConfirmsOrDie(TimeSpan timeout) { }
        public int ChannelNumber => 1;
        public ShutdownEventArgs CloseReason => null!;
        public IBasicConsumer DefaultConsumer { get; set; } = null!;
        public string CurrentQueue => "";
        public TimeSpan ContinuationTimeout { get; set; }
        public bool IsClosed => false;
        public bool IsOpen => true;
        public ulong NextPublishSeqNo => 0;
        public event EventHandler<BasicAckEventArgs>? BasicAcks;
        public event EventHandler<BasicNackEventArgs>? BasicNacks;
        public event EventHandler<EventArgs>? BasicRecoverOk;
        public event EventHandler<BasicReturnEventArgs>? BasicReturn;
        public event EventHandler<CallbackExceptionEventArgs>? CallbackException;
        public event EventHandler<FlowControlEventArgs>? FlowControl;
        public event EventHandler<ShutdownEventArgs>? ModelShutdown;
    }
    private class TestableConsumerService(IDataProcessingManager<FakeLogMessage> processor, RabbitMqSettings settings, ConsumerSettings consumerSettings, ConcurrentQueue<Action> queue, ILogger<ConsumerService<FakeLogMessage, ILogMessage>> logger, IConnection connection, ConsumerManager<FakeLogMessage, ILogMessage> manager) : ConsumerService<FakeLogMessage, ILogMessage>(processor, settings, consumerSettings, queue, logger, connection, manager)
    {
        public Task InvokeHandleMessageAsync(FakeLogMessage message, CancellationToken token)
            => HandleMessageAsync(message, token);
        public Task<bool> InvokeProcessBatchAsync(IEnumerable<FakeLogMessage> messages)
            => ProcessBatchAsync(messages);
        public async Task InvokePrepareBatchAsync(
            ConcurrentQueue<FakeLogMessage> queue,
            ConcurrentDictionary<ulong, byte> deliveryTags,
            IModel channel)
        {
            var method = typeof(ConsumerService<FakeLogMessage, ILogMessage>)
                .GetMethod("PrepareBatchAsync", BindingFlags.NonPublic | BindingFlags.Instance);
            if (method == null)
                throw new InvalidOperationException("PrepareBatchAsync method not found.");
            var task = (Task?)method.Invoke(this, [queue, deliveryTags, channel]);
            if (task != null)
                await task;
        }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Settings\ConsumerSettingsLoaderTests.cs

using Microsoft.Extensions.Configuration;
using Moq;
using RCS.RabbitMq.Consumer.Factories;
using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Settings;
public class ConsumerSettingsLoaderTests
{
    private readonly Mock<IConfigurationIntegrityValidator> _mockValidator = new();
    private static IConfiguration BuildConfiguration(Dictionary<string, string?> values)
    {
        return new ConfigurationBuilder()
            .AddInMemoryCollection(values)
            .Build();
    }
    [Fact]
    public void LoadSettings_Should_Return_Populated_Settings()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMq.Consumer:ServiceMappings:Log:MessageInterface"] = "ILogMessage",
            ["RCS.RabbitMq.Consumer:ServiceMappings:Log:MessageClass"] = "FakeLogMessage",
            ["RCS.RabbitMq.Consumer:ServiceMappings:Log:MessageMapper"] = "FakeMapper",
            ["RCS.RabbitMq.Consumer:MinConsumerCount"] = "1",
            ["RCS.RabbitMq.Consumer:MaxConsumerCount"] = "5",
            ["RCS.RabbitMq.Consumer:BatchSize"] = "10",
            ["RCS.RabbitMq.Consumer:InactivityTrigger"] = "1000",
            ["RCS.RabbitMq.Consumer:NonRetryableExceptions:0"] = "System.ArgumentException",
            ["RCS.RabbitMq.Consumer:NonRetryableExceptions:1"] = "System.InvalidOperationException"
        };
        var config = BuildConfiguration(configValues);
        var loader = new ConsumerSettingsLoader(_mockValidator.Object);
        
        var result = loader.LoadSettings(config);
        
        Assert.Equal("Log", result.MessageType);
        Assert.Equal("ILogMessage", result.MessageInterface);
        Assert.Equal("FakeLogMessage", result.MessageClass);
        Assert.Equal("FakeMapper", result.MessageMapper);
        Assert.Equal(1, result.MinConsumerCount);
        Assert.Equal(5, result.MaxConsumerCount);
        Assert.Equal(10, result.BatchSize);
        Assert.Equal(1000, result.InactivityTrigger);
        Assert.Contains("System.ArgumentException", result.NonRetryableExceptions);
        Assert.Contains("System.InvalidOperationException", result.NonRetryableExceptions);
    }
    [Fact]
    public void LoadSettings_Should_Throw_If_Required_Field_Missing()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMq.Consumer:ServiceMappings:Log:MessageInterface"] = "ILogMessage",
            
            ["RCS.RabbitMq.Consumer:ServiceMappings:Log:MessageMapper"] = "FakeMapper",
            ["RCS.RabbitMq.Consumer:MinConsumerCount"] = "1",
            ["RCS.RabbitMq.Consumer:MaxConsumerCount"] = "5",
            ["RCS.RabbitMq.Consumer:BatchSize"] = "10",
            ["RCS.RabbitMq.Consumer:InactivityTrigger"] = "1000"
        };
        var config = BuildConfiguration(configValues);
        var loader = new ConsumerSettingsLoader(_mockValidator.Object);
        
        var ex = Assert.Throws<ArgumentException>(() => loader.LoadSettings(config));
        Assert.Contains("MessageClass", ex.Message);
    }
    [Fact]
    public void LoadSettings_Should_Throw_If_Numeric_Field_Is_Invalid()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMq.Consumer:ServiceMappings:Log:MessageInterface"] = "ILogMessage",
            ["RCS.RabbitMq.Consumer:ServiceMappings:Log:MessageClass"] = "FakeLogMessage",
            ["RCS.RabbitMq.Consumer:ServiceMappings:Log:MessageMapper"] = "FakeMapper",
            ["RCS.RabbitMq.Consumer:MinConsumerCount"] = "1",
            ["RCS.RabbitMq.Consumer:MaxConsumerCount"] = "not-a-number", 
            ["RCS.RabbitMq.Consumer:BatchSize"] = "10",
            ["RCS.RabbitMq.Consumer:InactivityTrigger"] = "1000"
        };
        var config = BuildConfiguration(configValues);
        var loader = new ConsumerSettingsLoader(_mockValidator.Object);
        
        var ex = Assert.Throws<ArgumentException>(() => loader.LoadSettings(config));
        Assert.Contains("MaxConsumerCount", ex.Message);
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Settings\ProcessorSettingsLoaderTests.cs

using Microsoft.Extensions.Configuration;
using Moq;
using RCS.RabbitMq.Consumer.Factories;
using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Settings;
public class ProcessorSettingsLoaderTests
{
    private readonly Mock<IConfigurationIntegrityValidator> _mockValidator = new();
    private static IConfiguration BuildConfiguration(Dictionary<string, string?> values)
    {
        return new ConfigurationBuilder()
            .AddInMemoryCollection(values)
            .Build();
    }
    [Fact]
    public void LoadSettings_Should_Return_Populated_Settings()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMq.Consumer.Processor:ProcessorAssembly"] = "MyAssembly.dll",
            ["RCS.RabbitMq.Consumer.Processor:Class"] = "MyNamespace.MyClass"
        };
        var config = BuildConfiguration(configValues);
        var loader = new ProcessorSettingsLoader(_mockValidator.Object);
        
        var result = loader.LoadSettings(config);
        
        Assert.Equal("MyAssembly.dll", result.ProcessorAssembly);
        Assert.Equal("MyNamespace.MyClass", result.Class);
    }
    [Fact]
    public void LoadSettings_Should_Throw_If_Assembly_Missing()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMq.Consumer.Processor:Class"] = "MyNamespace.MyClass"
        };
        var config = BuildConfiguration(configValues);
        var loader = new ProcessorSettingsLoader(_mockValidator.Object);
        
        var ex = Assert.Throws<ArgumentException>(() => loader.LoadSettings(config));
        Assert.Contains("ProcessorAssembly", ex.Message);
    }
    [Fact]
    public void LoadSettings_Should_Throw_If_Class_Missing()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMq.Consumer.Processor:ProcessorAssembly"] = "MyAssembly.dll"
        };
        var config = BuildConfiguration(configValues);
        var loader = new ProcessorSettingsLoader(_mockValidator.Object);
        
        var ex = Assert.Throws<ArgumentException>(() => loader.LoadSettings(config));
        Assert.Contains("Class", ex.Message);
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Settings\RabbitMqSettingsLoaderTests.cs

using Microsoft.Extensions.Configuration;
using Moq;
using RCS.RabbitMq.Consumer.Factories;
using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Settings;
public class RabbitMqSettingsLoaderTests
{
    private readonly Mock<IConfigurationIntegrityValidator> _mockValidator = new();
    private static IConfiguration BuildConfiguration(Dictionary<string, string?> values)
    {
        return new ConfigurationBuilder()
            .AddInMemoryCollection(values)
            .Build();
    }
    [Fact]
    public void LoadSettings_Should_Return_Populated_Settings()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMQ:Host"] = "localhost",
            ["RCS.RabbitMQ:Username"] = "guest",
            ["RCS.RabbitMQ:Password"] = "guest",
            ["RCS.RabbitMQ:ExchangeName"] = "exchange",
            ["RCS.RabbitMQ:ExchangeType"] = "direct",
            ["RCS.RabbitMQ:QueueName"] = "queue",
            ["RCS.RabbitMQ:RoutingKey"] = "key",
            ["RCS.RabbitMQ:MaxRetry"] = "5",
            ["RCS.RabbitMQ:RetryQueueTimeToLive"] = "60000",
            ["RCS.RabbitMQ:MessageTimeToLive"] = "300000"
        };
        var config = BuildConfiguration(configValues);
        var loader = new RabbitMqSettingsLoader(_mockValidator.Object);
        
        var result = loader.LoadSettings(config);
        
        Assert.Equal("localhost", result.Host);
        Assert.Equal("guest", result.Username);
        Assert.Equal("exchange", result.ExchangeName);
        Assert.Equal("queue", result.QueueName);
        Assert.Equal(5, result.MaxRetry);
        Assert.Equal(60000, result.RetryQueueTimeToLive);
        Assert.Equal(300000, result.MessageTimeToLive);
    }
    [Fact]
    public void LoadSettings_Should_Throw_If_Missing_Required_Fields()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMQ:Host"] = "localhost",
            ["RCS.RabbitMQ:ExchangeName"] = "exchange",
            ["RCS.RabbitMQ:ExchangeType"] = "direct",
            ["RCS.RabbitMQ:QueueName"] = "queue"
        };
        var config = BuildConfiguration(configValues);
        var loader = new RabbitMqSettingsLoader(_mockValidator.Object);
        
        Assert.Throws<ArgumentException>(() => loader.LoadSettings(config));
    }
    [Fact]
    public void LoadSettings_Should_Throw_If_Numeric_Values_Invalid()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMQ:Host"] = "localhost",
            ["RCS.RabbitMQ:Username"] = "guest",
            ["RCS.RabbitMQ:Password"] = "guest",
            ["RCS.RabbitMQ:ExchangeName"] = "exchange",
            ["RCS.RabbitMQ:ExchangeType"] = "direct",
            ["RCS.RabbitMQ:QueueName"] = "queue",
            ["RCS.RabbitMQ:RoutingKey"] = "key",
            ["RCS.RabbitMQ:MaxRetry"] = "abc", 
            ["RCS.RabbitMQ:RetryQueueTimeToLive"] = "abc", 
            ["RCS.RabbitMQ:MessageTimeToLive"] = "300000"
        };
        var config = BuildConfiguration(configValues);
        var loader = new RabbitMqSettingsLoader(_mockValidator.Object);
        
        var ex = Assert.Throws<ArgumentException>(() => loader.LoadSettings(config));
        Assert.Contains("RetryQueueTimeToLive", ex.Message);
    }
    [Fact]
    public void LoadSettings_Should_Throw_If_MaxRetry_Not_Valid_Int()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMQ:Host"] = "localhost",
            ["RCS.RabbitMQ:Username"] = "guest",
            ["RCS.RabbitMQ:Password"] = "guest",
            ["RCS.RabbitMQ:ExchangeName"] = "exchange",
            ["RCS.RabbitMQ:ExchangeType"] = "direct",
            ["RCS.RabbitMQ:QueueName"] = "queue",
            ["RCS.RabbitMQ:RoutingKey"] = "key",
            ["RCS.RabbitMQ:MaxRetry"] = "abc", 
            ["RCS.RabbitMQ:RetryQueueTimeToLive"] = "60000",
            ["RCS.RabbitMQ:MessageTimeToLive"] = "300000"
        };
        var config = BuildConfiguration(configValues);
        var loader = new RabbitMqSettingsLoader(_mockValidator.Object);
        
        var ex = Assert.Throws<ArgumentException>(() => loader.LoadSettings(config));
        Assert.Contains("MaxRetry", ex.Message);
    }
    [Fact]
    public void LoadSettings_Should_Throw_If_RetryQueueTimeToLive_Not_Valid_Int()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMQ:Host"] = "localhost",
            ["RCS.RabbitMQ:Username"] = "guest",
            ["RCS.RabbitMQ:Password"] = "guest",
            ["RCS.RabbitMQ:ExchangeName"] = "exchange",
            ["RCS.RabbitMQ:ExchangeType"] = "direct",
            ["RCS.RabbitMQ:QueueName"] = "queue",
            ["RCS.RabbitMQ:RoutingKey"] = "key",
            ["RCS.RabbitMQ:MaxRetry"] = "5",
            ["RCS.RabbitMQ:RetryQueueTimeToLive"] = "xyz", 
            ["RCS.RabbitMQ:MessageTimeToLive"] = "300000"
        };
        var config = BuildConfiguration(configValues);
        var loader = new RabbitMqSettingsLoader(_mockValidator.Object);
        
        var ex = Assert.Throws<ArgumentException>(() => loader.LoadSettings(config));
        Assert.Contains("RetryQueueTimeToLive", ex.Message);
    }
    [Fact]
    public void LoadSettings_Should_Throw_If_MessageTimeToLive_Not_Valid_Int()
    {
        
        var configValues = new Dictionary<string, string?>
        {
            ["RCS.RabbitMQ:Host"] = "localhost",
            ["RCS.RabbitMQ:Username"] = "guest",
            ["RCS.RabbitMQ:Password"] = "guest",
            ["RCS.RabbitMQ:ExchangeName"] = "exchange",
            ["RCS.RabbitMQ:ExchangeType"] = "direct",
            ["RCS.RabbitMQ:QueueName"] = "queue",
            ["RCS.RabbitMQ:RoutingKey"] = "key",
            ["RCS.RabbitMQ:MaxRetry"] = "5",
            ["RCS.RabbitMQ:RetryQueueTimeToLive"] = "60000",
            ["RCS.RabbitMQ:MessageTimeToLive"] = "notanumber" 
        };
        var config = BuildConfiguration(configValues);
        var loader = new RabbitMqSettingsLoader(_mockValidator.Object);
        
        var ex = Assert.Throws<ArgumentException>(() => loader.LoadSettings(config));
        Assert.Contains("MessageTimeToLive", ex.Message);
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Utilities\StubConsumerServiceWithFixedTag.cs

using System.Collections.Concurrent;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using RabbitMQ.Client;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Tests.Consumer.Models;
namespace RCS.RabbitMq.Tests.Consumer.Utilities;
public class StubConsumerServiceWithFixedTag(
    IServiceProvider provider,
    string tag) : ConsumerService<FakeLogMessage, ILogMessage>(
    provider.GetRequiredService<IDataProcessingManager<FakeLogMessage>>(),
    provider.GetRequiredService<RabbitMqSettings>(),
    provider.GetRequiredService<ConsumerSettings>(),
    provider.GetRequiredService<ConcurrentQueue<Action>>(),
    provider.GetRequiredService<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
    provider.GetRequiredService<IConnection>(),
    provider.GetRequiredService<ConsumerManager<FakeLogMessage, ILogMessage>>())
{
    public override string? StartConsuming(CancellationToken cancellationToken) => tag;
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Utilities\StubConsumerServiceWithFixedTagReturningNonNull.cs

using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Tests.Consumer.Models;
namespace RCS.RabbitMq.Tests.Consumer.Utilities
{
    public class StubConsumerServiceWithFixedTagReturningNonNull : IConsumerService<FakeLogMessage, ILogMessage>
    {
        public string StartConsuming(CancellationToken cancellationToken) => "valid-consumer-tag";
        public void StopConsuming(CancellationToken cancellationToken) { }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Utilities\TestableConsumerManager.cs

using Microsoft.Extensions.Logging;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Shared.Interfaces;
using RCS.RabbitMq.Tests.Consumer.Models;
namespace RCS.RabbitMq.Tests.Consumer.Utilities;
public class TestableConsumerManager : ConsumerManager<FakeLogMessage, ILogMessage>
{
    private readonly ConsumerService<FakeLogMessage, ILogMessage> _stub;
    public TestableConsumerManager(
        ScalingCommandHandler handler,
        IServiceProvider provider,
        ILogger<ConsumerManager<FakeLogMessage, ILogMessage>> logger,
        IRabbitMessageMapper<FakeLogMessage, ILogMessage> mapper,
        ConsumerService<FakeLogMessage, ILogMessage> stub)
        : base(handler, provider, logger, mapper)
    {
        _stub = stub;
    }
    protected override ConsumerService<FakeLogMessage, ILogMessage> CreateConsumerService() => _stub;
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Utilities\TestConsumerService.cs

using System.Collections.Concurrent;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using RabbitMQ.Client;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Tests.Consumer.Models;
namespace RCS.RabbitMq.Tests.Consumer.Utilities;
public class TestConsumerService : ConsumerService<FakeLogMessage, ILogMessage>, IConsumerService<FakeLogMessage, ILogMessage>
{
    public TestConsumerService(IServiceProvider sp)
        : base(
            sp.GetRequiredService<IDataProcessingManager<FakeLogMessage>>(),
            sp.GetRequiredService<RabbitMqSettings>(),
            sp.GetRequiredService<ConsumerSettings>(),
            sp.GetRequiredService<ConcurrentQueue<Action>>(),
            sp.GetRequiredService<ILogger<ConsumerService<FakeLogMessage, ILogMessage>>>(),
            sp.GetRequiredService<IConnection>(),
            sp.GetRequiredService<ConsumerManager<FakeLogMessage, ILogMessage>>()
        )
    { }
    public override string? StartConsuming(CancellationToken cancellationToken) => null; 
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\Utilities\TestHelper.cs

using System.Collections.Concurrent;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Moq;
using RabbitMQ.Client;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Shared.Interfaces;
using RCS.RabbitMq.Tests.Consumer.Models;
using RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Interfaces;
namespace RCS.RabbitMq.Tests.Consumer.Utilities;
public static class TestHelper
{
    public static ServiceProvider BuildValidLogMessageServiceProvider(
        bool includeLogger = true,
        bool includeConsumerManager = true,
        bool includeRabbitMqSettings = true)
    {
        return BuildValidServiceProvider<FakeLogMessage, ILogMessage>(
            includeLogger,
            includeConsumerManager,
            includeRabbitMqSettings);
    }
    public static ServiceProvider BuildValidWhatsAppMessageServiceProvider(
        bool includeLogger = true,
        bool includeConsumerManager = true,
        bool includeRabbitMqSettings = true)
    {
        return BuildValidServiceProvider<FakeWhatsAppMessage, IWhatsAppMessage>(
            includeLogger,
            includeConsumerManager,
            includeRabbitMqSettings);
    }
    public static ServiceProvider BuildValidServiceProvider<TMessage, TContract>(
        bool includeLogger = true,
        bool includeConsumerManager = true,
        bool includeRabbitMqSettings = true)
        where TMessage : class, IAcknowledgeableRabbitMessage, new()
        where TContract : class, IBasicMessageContract
    {
        var services = new ServiceCollection();
        if (includeConsumerManager)
        {
            
            services.AddSingleton<IConsumerManager<TMessage, TContract>, ConsumerManager<TMessage, TContract>>();
            services.AddSingleton<ConsumerManager<TMessage, TContract>>();
            services.AddSingleton<ScalingCommandHandler>();
            services.AddSingleton(new ConcurrentQueue<Action>());
            var mockConsumerManagerLogger = new Mock<ILogger<ConsumerManager<TMessage, TContract>>>();
            services.AddSingleton(mockConsumerManagerLogger.Object);
            var mockScalingLogger = new Mock<ILogger<ScalingCommandHandler>>();
            services.AddSingleton(mockScalingLogger.Object);
            var mockMapper = new Mock<IRabbitMessageMapper<TMessage, TContract>>();
            mockMapper.Setup(m => m.Map(It.IsAny<TMessage>())).Returns(Mock.Of<TContract>());
            services.AddSingleton(mockMapper.Object);
            var mockDataProcessor = new Mock<IDataProcessingManager<TMessage>>();
            services.AddSingleton(mockDataProcessor.Object);
            services.AddSingleton(new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(TMessage).FullName!,
                MessageInterface = typeof(TContract).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = typeof(TMessage).Name,
                ProcessorAssembly = typeof(TMessage).Assembly.FullName!,
                ProcessorClass = typeof(TMessage).FullName!,
                NonRetryableExceptions = []
            });
        }
        if (includeLogger)
        {
            var mockLogger = new Mock<ILogger<MonitoringService<TMessage, TContract>>>();
            services.AddSingleton(mockLogger.Object);
        }
        if (includeRabbitMqSettings)
        {
            services.AddSingleton(new RabbitMqSettings
            {
                ExchangeName = "test.exchange",
                ExchangeType = "fanout",
                Host = "localhost",
                Password = "guest",
                QueueName = "test.queue",
                Username = "guest"
            });
        }
        return services.BuildServiceProvider();
    }
    public static IServiceProvider BuildValidConsumerServiceProvider<TMessage, TContract>(
        bool includeLogger = true,
        bool includeConsumerManager = true,
        bool includeDataProcessor = true,
        bool includeRabbitMqSettings = true,
        bool includeConsumerSettings = true,
        bool includeScalingQueue = true,
        bool includeConnection = true,
        bool includeMapper = true)
        where TMessage : class, IAcknowledgeableRabbitMessage, new()
        where TContract : class, IBasicMessageContract
    {
        var services = new ServiceCollection();
        if (includeConsumerManager)
        {
            services.AddSingleton(Mock.Of<ILogger<ScalingCommandHandler>>());
            services.AddSingleton(Mock.Of<ILogger<ConsumerManager<TMessage, TContract>>>());
            services.AddSingleton<ScalingCommandHandler>();
            services.AddSingleton<ConsumerManager<TMessage, TContract>>();
        }
        if (includeDataProcessor)
        {
            var mock = new Mock<IDataProcessingManager<TMessage>>();
            services.AddSingleton(mock.Object);
        }
        if (includeLogger)
        {
            var mockLogger = new Mock<ILogger<ConsumerService<TMessage, TContract>>>();
            services.AddSingleton(mockLogger.Object);
        }
        if (includeRabbitMqSettings)
        {
            services.AddSingleton(new RabbitMqSettings
            {
                ExchangeName = "test.exchange",
                ExchangeType = "direct",
                Host = "localhost",
                Password = "guest",
                QueueName = "test.queue",
                Username = "guest"
            });
        }
        if (includeConsumerSettings)
        {
            services.AddSingleton(new ConsumerSettings
            {
                BatchSize = 10,
                InactivityTrigger = 1000,
                MaxConsumerCount = 5,
                MinConsumerCount = 1,
                MessageClass = typeof(TMessage).FullName!,
                MessageInterface = typeof(TContract).FullName!,
                MessageMapper = typeof(FakeMapper).FullName!,
                MessageType = typeof(TMessage).Name,
                ProcessorAssembly = typeof(TMessage).Assembly.FullName!,
                ProcessorClass = typeof(TMessage).FullName!,
                NonRetryableExceptions = []
            });
        }
        if (includeScalingQueue)
        {
            services.AddSingleton(new ConcurrentQueue<Action>());
        }
        if (includeConnection)
        {
            services.AddSingleton(Mock.Of<IConnection>());
        }
        if (includeMapper)
        {
            var mock = new Mock<IRabbitMessageMapper<TMessage, TContract>>();
            mock.Setup(m => m.Map(It.IsAny<TMessage>())).Returns(Mock.Of<TContract>());
            services.AddSingleton(mock.Object);
        }
        return services.BuildServiceProvider();
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Consumer\appsettings.DEV.json

{
  "RCS.RabbitMQ": {
    "Host": "rcscptdappws10",
    "Username": "svc_cm_d",
    "Password": "svc_cm_d",
    "ExchangeName": "cm_actionlog",
    "ExchangeType": "direct",
    "QueueName": "cm_actionlog",
    "RoutingKey": "cm_actionlog",
    "MessageTimeToLive": 3600,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  },
  "RCS.RabbitMQ.Consumer.Processor": {
    "ProcessorAssembly": "RCS.RabbitMq.CM_ActionLog.Processor.dll",
    "Class": "RCS.RabbitMq.CM_ActionLog.Processor.Message"
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Consumer\appsettings.json

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "Debug"
      },
      {
        "Name": "File",
        "Args": {
          "Path": "C:/Logs/RabbitMq/Consumers/WhatsApp/WhatsApp.Consumer.txt",
          "RollingInterval": "Day"
        }
      }
    ]
  },
  "RCS.RabbitMQ.Consumer": {
    "ServiceMappings": {
      "WhatsAppMessage": {
        "MessageInterface": "RCS.RabbitMq.Shared.Contracts.Interfaces.IWhatsAppMessage",
        "MessageClass": "RCS.RabbitMq.Shared.Contracts.Models.WhatsAppMessage",
        "MessageMapper": "RCS.RabbitMq.Shared.Models.WhatsAppMessageMapper"
      }
    },
    "MinConsumerCount": 10,
    "MaxConsumerCount": 50,
    "BatchSize": 2500,
    "InactivityTrigger": 10,
    "NonRetryableExceptions": [
      "System.ArgumentException",
      "System.InvalidOperationException",
      "System.NullReferenceException",
      "System.FormatException",
      "System.NotSupportedException"
    ]
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Consumer\appsettings.PROD.json

{
  "RCS.RabbitMQ": {
    "Host": "rcscptpappws10",
    "Username": "svc_cm_p",
    "Password": "svc_cm_p",
    "ExchangeName": "cm_actionlog",
    "ExchangeType": "direct",
    "QueueName": "cm_actionlog",
    "RoutingKey": "cm_actionlog",
    "MessageTimeToLive": 3600,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  },
  "RCS.RabbitMQ.Consumer.Processor": {
    "ProcessorAssembly": "RCS.RabbitMq.CM_ActionLog.Processor.dll",
    "Class": "RCS.RabbitMq.CM_ActionLog.Processor.Message"
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Consumer\appsettings.SIT.json

{
  "RCS.RabbitMQ": {
    "Host": "rcscptsappws10",
    "Username": "svc_cm_s",
    "Password": "svc_cm_s",
    "ExchangeName": "cm_actionlog",
    "ExchangeType": "direct",
    "QueueName": "cm_actionlog",
    "RoutingKey": "cm_actionlog",
    "MessageTimeToLive": 3600,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  },
  "RCS.RabbitMQ.Consumer.Processor": {
    "ProcessorAssembly": "RCS.RabbitMq.CM_ActionLog.Processor.dll",
    "Class": "RCS.RabbitMq.CM_ActionLog.Processor.Message"
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Consumer\appsettings.UAT.json

{
  "RCS.RabbitMQ": {
    "Host": "rcscptuappws10",
    "Username": "svc_cm_u",
    "Password": "svc_cm_u",
    "ExchangeName": "cm_actionlog",
    "ExchangeType": "direct",
    "QueueName": "cm_actionlog",
    "RoutingKey": "cm_actionlog",
    "MessageTimeToLive": 3600,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  },
  "RCS.RabbitMQ.Consumer.Processor": {
    "ProcessorAssembly": "RCS.RabbitMq.CM_ActionLog.Processor.dll",
    "Class": "RCS.RabbitMq.CM_ActionLog.Processor.Message"
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Processor\appsettings.DEV.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Processor\appsettings.json

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "Debug"
      },
      {
        "Name": "File",
        "Args": {
          "Path": "C:/Logs/RabbitMq/Consumers/WhatsApp/WhatsApp.Processor.txt",
          "RollingInterval": "Day"
        }
      }
    ]
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Processor\appsettings.PROD.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Processor\appsettings.SIT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Tests\RCS.RabbitMq.Tests\bin\Debug\net8.0\Config\Processor\appsettings.UAT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Program.cs

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using RabbitMQ.Client;
using RCS.RabbitMq.Consumer.Factories;
using RCS.RabbitMq.Consumer.Initialisation;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Processing;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Shared.Interfaces;
using RCS.RabbitMq.Shared.Services;
using Serilog;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
namespace RCS.RabbitMq.Consumer;




internal static class Program
{
    
    
    
    private static async Task Main(string[] args)
    {
        try
        {
            var environmentName = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "PROD";
            
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile($"Config/Consumer/appsettings.json", optional: false, reloadOnChange: true)
                .AddJsonFile($"Config/Consumer/appsettings.{environmentName}.json", optional: false, reloadOnChange: true)
                .Build();
            
            var minimumLogLevel = configuration.GetSection("Serilog:MinimumLevel:Default").Value ?? "Information";
            if (!Enum.TryParse(minimumLogLevel, true, out Serilog.Events.LogEventLevel logLevel))
                logLevel = Serilog.Events.LogEventLevel.Information;
            
            var filePath = configuration.GetSection("Serilog:WriteTo")
                .GetChildren()
                .FirstOrDefault(x => x.GetValue<string>("Name") == "File")
                ?.GetSection("Args")
                .GetValue<string>("Path");
            if (!string.IsNullOrWhiteSpace(filePath))
            {
                var directory = Path.GetDirectoryName(filePath);
                var fileName = Path.GetFileNameWithoutExtension(filePath);
                var extension = Path.GetExtension(filePath);
                var modifiedPath = Path.Combine(directory ?? "", $"{fileName}_Consumer_{extension}");
                if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                    Directory.CreateDirectory(directory);
                Log.Logger = new LoggerConfiguration()
                    .MinimumLevel.Is(logLevel)
                    .WriteTo.Console()
                    .WriteTo.File(modifiedPath, rollingInterval: RollingInterval.Day)
                    .CreateLogger();
                Log.Information("Serilog initialised with modified file path: {ModifiedPath}", modifiedPath);
            }
            else
            {
                throw new InvalidOperationException("Failed to find the file path in configuration.");
            }
            var isWindowsService = !(Debugger.IsAttached || args.Contains("--console"));
            
            var hostBuilder = Host.CreateDefaultBuilder(args)
                .ConfigureHostConfiguration(cfg => cfg.AddEnvironmentVariables(prefix: "ASPNETCORE_"))
                .ConfigureAppConfiguration((_, cfg) => cfg.AddConfiguration(configuration))
                .ConfigureServices((context, services) =>
                {
                    ConfigureCommonServices(services, context.Configuration);
                    ConfigureRabbitMqServices(services, context.Configuration);
                    ConfigureHostedServices(services);
                })
                .UseSerilog(Log.Logger);
            if (isWindowsService)
            {
                hostBuilder.UseWindowsService();
                Log.Information("Running as a Windows Service.");
            }
            else
            {
                Log.Information("Running as a console app for debugging.");
            }
            var host = hostBuilder.Build();
            await host.RunAsync();
        }
        catch (Exception ex)
        {
            Log.Fatal(ex, "Critical error");
        }
        finally
        {
            await Log.CloseAndFlushAsync();
        }
    }
    
    
    
    
    private static void ConfigureCommonServices(IServiceCollection services, IConfiguration configuration)
    {
        var consumerSettingsLoader = new ConsumerSettingsLoader(new ConfigurationIntegrityValidator());
        var consumerSettings = consumerSettingsLoader.LoadSettings(configuration);
        services.AddSingleton(consumerSettings);
        services.AddSingleton(new ConcurrentQueue<Action>());
        services.AddSingleton(configuration);
        services.AddSingleton<IConfigurationIntegrityValidator, ConfigurationIntegrityValidator>();
        services.AddSingleton<ISettingsLoader<ConsumerSettings>, ConsumerSettingsLoader>();
        services.AddSingleton<ISettingsLoader<RabbitMqSettings>, RabbitMqSettingsLoader>();
        services.AddSingleton<ISettingsLoader<ProcessorSettings>, ProcessorSettingsLoader>();
        services.AddSingleton<ScalingCommandHandler>();
        
        var processorSettingsLoader = new ProcessorSettingsLoader();
        var processorSettings = processorSettingsLoader.LoadSettings(configuration);
        services.AddSingleton(processorSettings);
        
        const string consumerAssemblyName = "RCS.RabbitMq.Consumer";
        const string processingManagerBase = "RCS.RabbitMq.Consumer.Processing.DataProcessingManager`1";
        const string consumerManagerBase = "RCS.RabbitMq.Consumer.Managers.ConsumerManager`2";
        var sharedContractsPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)
            ?? throw new InvalidOperationException("Processor DLL could not be located."),
            consumerSettings.ProcessorAssembly);
        var sharedContractsAssembly = Assembly.LoadFrom(sharedContractsPath);
        var messageType = sharedContractsAssembly.GetType(consumerSettings.MessageClass);
        var interfaceType = sharedContractsAssembly.GetType(consumerSettings.MessageInterface);
        var mapperType = sharedContractsAssembly.GetType(consumerSettings.MessageMapper);
        var consumerAssembly = Assembly.Load(consumerAssemblyName);
        if (messageType == null || interfaceType == null || mapperType == null)
            throw new InvalidOperationException($"Unable to resolve types for {consumerSettings.MessageClass}.");
        var processingManagerType = consumerAssembly.GetType(processingManagerBase)!.MakeGenericType(messageType);
        var consumerManagerType = consumerAssembly.GetType(consumerManagerBase)!.MakeGenericType(messageType, interfaceType);
        services.AddSingleton(typeof(IRabbitMessageMapper<,>).MakeGenericType(messageType, interfaceType), mapperType);
        services.AddSingleton(typeof(IDataProcessingManager<>).MakeGenericType(messageType), processingManagerType);
        services.AddSingleton(consumerManagerType);
        services.AddSingleton(_ => messageType);
    }
    
    
    
    private static void ConfigureRabbitMqServices(IServiceCollection services, IConfiguration configuration)
    {
        var rabbitMqSettingsLoader = new RabbitMqSettingsLoader(new ConfigurationIntegrityValidator());
        var rabbitMqSettings = rabbitMqSettingsLoader.LoadSettings(configuration);
        services.AddSingleton(rabbitMqSettings);
        services.AddSingleton<IConnection>(_ =>
        {
            var factory = new ConnectionFactory
            {
                HostName = rabbitMqSettings.Host,
                UserName = rabbitMqSettings.Username,
                Password = rabbitMqSettings.Password,
                DispatchConsumersAsync = true,
                RequestedHeartbeat = TimeSpan.FromSeconds(30),
                AutomaticRecoveryEnabled = true
            };
            return factory.CreateConnection();
        });
        services.AddSingleton(provider => provider.GetRequiredService<IConnection>().CreateModel());
        services.AddSingleton<IRabbitMqInitialiser, RabbitMqInitialiser>();
        services.AddSingleton(typeof(IDataProcessingManager<>), typeof(DataProcessingManager<>));
    }
    
    
    
    private static void ConfigureHostedServices(IServiceCollection services)
    {
        services.AddHostedService<RabbitMqHostedInitialiser>();
        services.AddSingleton<IHostedService>(provider =>
        {
            var resolvedMessageType = provider.GetRequiredService<Type>();
            var consumerService = RegisterConsumerService(provider, resolvedMessageType);
            RegisterMonitoringService(provider, resolvedMessageType);
            return consumerService;
        });
    }
    
    
    
    private static IHostedService RegisterConsumerService(IServiceProvider provider, Type messageType)
    {
        var consumerSettings = provider.GetRequiredService<ConsumerSettings>();
        var rabbitMqSettings = provider.GetRequiredService<RabbitMqSettings>();
        var scalingCommands = provider.GetRequiredService<ConcurrentQueue<Action>>();
        var connection = provider.GetRequiredService<IConnection>();
        var contractType = GetContractType(messageType);
        var consumerManagerType = typeof(ConsumerManager<,>).MakeGenericType(messageType, contractType);
        var consumerManager = provider.GetRequiredService(consumerManagerType);
        var processorType = typeof(IDataProcessingManager<>).MakeGenericType(messageType);
        var dataProcessor = provider.GetRequiredService(processorType);
        var consumerServiceType = typeof(ConsumerService<,>).MakeGenericType(messageType, contractType);
        var loggerType = typeof(ILogger<>).MakeGenericType(consumerServiceType);
        var logger = provider.GetRequiredService(loggerType);
        return Activator.CreateInstance(
            consumerServiceType,
            dataProcessor,
            rabbitMqSettings,
            consumerSettings,
            scalingCommands,
            logger,
            connection,
            consumerManager) as IHostedService
            ?? throw new InvalidOperationException($"Failed to create {consumerServiceType.Name}");
    }
    
    
    
    private static void RegisterMonitoringService(IServiceProvider provider, Type messageType)
    {
        var rabbitMqConfig = provider.GetRequiredService<RabbitMqSettings>();
        var contractType = GetContractType(messageType);
        var consumerManagerType = typeof(ConsumerManager<,>).MakeGenericType(messageType, contractType);
        var consumerManager = provider.GetRequiredService(consumerManagerType);
        var monitoringServiceType = typeof(MonitoringService<,>).MakeGenericType(messageType, contractType);
        var loggerType = typeof(ILogger<>).MakeGenericType(monitoringServiceType);
        var logger = provider.GetRequiredService(loggerType);
        _ = Activator.CreateInstance(monitoringServiceType, rabbitMqConfig, consumerManager, logger)
            ?? throw new InvalidOperationException($"Failed to create {monitoringServiceType.Name}");
    }
    
    
    
    private static Type GetContractType(Type messageType)
    {
        return Utilities.ContractTypeResolver.GetContractType(messageType);
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\AckDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class AckDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\Arguments.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class Arguments
{
    [JsonPropertyName("x-dead-letter-exchange")]
    public string XDeadLetterExchange { get; set; } = string.Empty;
    [JsonPropertyName("x-dead-letter-routing-key")]
    public string XDeadLetterRoutingKey { get; set; } = string.Empty;
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\ChannelDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class ChannelDetails
{
    [JsonPropertyName("connection_name")]
    public required string ConnectionName { get; set; }
    [JsonPropertyName("name")]
    public required string Name { get; set; }
    [JsonPropertyName("node")]
    public required string Node { get; set; }
    [JsonPropertyName("number")]
    public required int Number { get; set; }
    [JsonPropertyName("peer_host")]
    public required string PeerHost { get; set; }
    [JsonPropertyName("peer_port")]
    public required int PeerPort { get; set; }
    [JsonPropertyName("user")]
    public required string User { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\ConsumerDetail.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class ConsumerDetail
{
    [JsonPropertyName("arguments")]
    public required Arguments Arguments { get; set; }
    [JsonPropertyName("channel_details")]
    public required ChannelDetails ChannelDetails { get; set; }
    [JsonPropertyName("ack_required")]
    public required bool AckRequired { get; set; }
    [JsonPropertyName("active")]
    public required bool Active { get; set; }
    [JsonPropertyName("activity_status")]
    public required string ActivityStatus { get; set; }
    [JsonPropertyName("consumer_tag")]
    public required string ConsumerTag { get; set; }
    [JsonPropertyName("consumer_timeout")]
    public required int ConsumerTimeout { get; set; }
    [JsonPropertyName("exclusive")]
    public required bool Exclusive { get; set; }
    [JsonPropertyName("prefetch_count")]
    public required int PrefetchCount { get; set; }
    [JsonPropertyName("queue")]
    public required Queue Queue { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\DeliverDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class DeliverDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\DeliverGetDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class DeliverGetDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\DeliverNoAckDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class DeliverNoAckDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\EffectivePolicyDefinition.cs

namespace RCS.RabbitMq.Consumer.Dtos;
public class EffectivePolicyDefinition;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\GarbageCollection.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class GarbageCollection
{
    [JsonPropertyName("fullsweep_after")]
    public required int FullsweepAfter { get; set; }
    [JsonPropertyName("max_heap_size")]
    public required int MaxHeapSize { get; set; }
    [JsonPropertyName("min_bin_vheap_size")]
    public required int MinBinVheapSize { get; set; }
    [JsonPropertyName("min_heap_size")]
    public required int MinHeapSize { get; set; }
    [JsonPropertyName("minor_gcs")]
    public required int MinorGcs { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\GetDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class GetDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\GetEmptyDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class GetEmptyDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\GetNoAckDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class GetNoAckDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\MessagesDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class MessagesDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\MessagesReadyDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class MessagesReadyDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\MessageStats.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class MessageStats
{
    [JsonPropertyName("ack")]
    public required int Ack { get; set; }
    [JsonPropertyName("ack_details")]
    public required AckDetails AckDetails { get; set; }
    [JsonPropertyName("deliver")]
    public required int Deliver { get; set; }
    [JsonPropertyName("deliver_details")]
    public required DeliverDetails DeliverDetails { get; set; }
    [JsonPropertyName("deliver_get")]
    public required int DeliverGet { get; set; }
    [JsonPropertyName("deliver_get_details")]
    public required DeliverGetDetails DeliverGetDetails { get; set; }
    [JsonPropertyName("deliver_no_ack")]
    public required int DeliverNoAck { get; set; }
    [JsonPropertyName("deliver_no_ack_details")]
    public required DeliverNoAckDetails DeliverNoAckDetails { get; set; }
    [JsonPropertyName("get")]
    public required int Get { get; set; }
    [JsonPropertyName("get_details")]
    public required GetDetails GetDetails { get; set; }
    [JsonPropertyName("get_empty")]
    public required int GetEmpty { get; set; }
    [JsonPropertyName("get_empty_details")]
    public required GetEmptyDetails GetEmptyDetails { get; set; }
    [JsonPropertyName("get_no_ack")]
    public required int GetNoAck { get; set; }
    [JsonPropertyName("get_no_ack_details")]
    public required GetNoAckDetails GetNoAckDetails { get; set; }
    [JsonPropertyName("publish")]
    public required int Publish { get; set; }
    [JsonPropertyName("publish_details")]
    public required PublishDetails PublishDetails { get; set; }
    [JsonPropertyName("redeliver")]
    public required int Redeliver { get; set; }
    [JsonPropertyName("redeliver_details")]
    public required RedeliverDetails RedeliverDetails { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\MessagesUnacknowledgedDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class MessagesUnacknowledgedDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\PublishDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class PublishDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\Queue.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class Queue
{
    [JsonPropertyName("name")]
    public required string Name { get; set; }
    [JsonPropertyName("vhost")]
    public required string Vhost { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\RedeliverDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class RedeliverDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\ReductionsDetails.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class ReductionsDetails
{
    [JsonPropertyName("rate")]
    public required double Rate { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Dtos\Root.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Consumer.Dtos;
public class Root
{
    [JsonPropertyName("consumer_details")]
    public required List<ConsumerDetail> ConsumerDetails { get; set; }
    [JsonPropertyName("arguments")]
    public required Arguments Arguments { get; set; }
    [JsonPropertyName("auto_delete")]
    public required bool AutoDelete { get; set; }
    [JsonPropertyName("consumer_capacity")]
    public required double ConsumerCapacity { get; set; }
    [JsonPropertyName("consumer_utilisation")]
    public required double ConsumerUtilisation { get; set; }
    [JsonPropertyName("consumers")]
    public required int Consumers { get; set; }
    [JsonPropertyName("deliveries")]
    public required List<object> Deliveries { get; set; }
    [JsonPropertyName("durable")]
    public required bool Durable { get; set; }
    [JsonPropertyName("effective_policy_definition")]
    public required EffectivePolicyDefinition EffectivePolicyDefinition { get; set; }
    [JsonPropertyName("exclusive")]
    public required bool Exclusive { get; set; }
    [JsonPropertyName("exclusive_consumer_tag")]
    public required object ExclusiveConsumerTag { get; set; }
    [JsonPropertyName("garbage_collection")]
    public required GarbageCollection GarbageCollection { get; set; }
    [JsonPropertyName("head_message_timestamp")]
    public required object HeadMessageTimestamp { get; set; }
    [JsonPropertyName("incoming")]
    public required List<object> Incoming { get; set; }
    [JsonPropertyName("memory")]
    public required int Memory { get; set; }
    [JsonPropertyName("message_bytes")]
    public required int MessageBytes { get; set; }
    [JsonPropertyName("message_bytes_paged_out")]
    public required int MessageBytesPagedOut { get; set; }
    [JsonPropertyName("message_bytes_persistent")]
    public required int MessageBytesPersistent { get; set; }
    [JsonPropertyName("message_bytes_ram")]
    public required int MessageBytesRam { get; set; }
    [JsonPropertyName("message_bytes_ready")]
    public required int MessageBytesReady { get; set; }
    [JsonPropertyName("message_bytes_unacknowledged")]
    public required int MessageBytesUnacknowledged { get; set; }
    [JsonPropertyName("message_stats")]
    public required MessageStats MessageStats { get; set; }
    [JsonPropertyName("messages")]
    public required int Messages { get; set; }
    [JsonPropertyName("messages_details")]
    public required MessagesDetails MessagesDetails { get; set; }
    [JsonPropertyName("messages_paged_out")]
    public required int MessagesPagedOut { get; set; }
    [JsonPropertyName("messages_persistent")]
    public required int MessagesPersistent { get; set; }
    [JsonPropertyName("messages_ram")]
    public required int MessagesRam { get; set; }
    [JsonPropertyName("messages_ready")]
    public required int MessagesReady { get; set; }
    [JsonPropertyName("messages_ready_details")]
    public required MessagesReadyDetails MessagesReadyDetails { get; set; }
    [JsonPropertyName("messages_ready_ram")]
    public required int MessagesReadyRam { get; set; }
    [JsonPropertyName("messages_unacknowledged")]
    public required int MessagesUnacknowledged { get; set; }
    [JsonPropertyName("messages_unacknowledged_details")]
    public required MessagesUnacknowledgedDetails MessagesUnacknowledgedDetails { get; set; }
    [JsonPropertyName("messages_unacknowledged_ram")]
    public required int MessagesUnacknowledgedRam { get; set; }
    [JsonPropertyName("name")]
    public required string Name { get; set; }
    [JsonPropertyName("node")]
    public required string Node { get; set; }
    [JsonPropertyName("operator_policy")]
    public required object OperatorPolicy { get; set; }
    [JsonPropertyName("policy")]
    public required object Policy { get; set; }
    [JsonPropertyName("recoverable_slaves")]
    public required object RecoverableSlaves { get; set; }
    [JsonPropertyName("reductions")]
    public required long Reductions { get; set; }
    [JsonPropertyName("reductions_details")]
    public required ReductionsDetails ReductionsDetails { get; set; }
    [JsonPropertyName("single_active_consumer_tag")]
    public required object SingleActiveConsumerTag { get; set; }
    [JsonPropertyName("state")]
    public required string State { get; set; }
    [JsonPropertyName("storage_version")]
    public required int StorageVersion { get; set; }
    [JsonPropertyName("type")]
    public required string Type { get; set; }
    [JsonPropertyName("vhost")]
    public required string Vhost { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Factories\ConsumerServiceFactory.cs

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using RabbitMQ.Client;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Consumer.Utilities;
using System.Collections.Concurrent;
namespace RCS.RabbitMq.Consumer.Factories;



public class ConsumerServiceFactory(IServiceProvider provider) : IConsumerServiceFactory
{
    
    
    
    
    
    
    public IHostedService Create(Type messageType)
    {
        
        var contractType = GetContractType(messageType);
        
        var consumerManagerType = typeof(ConsumerManager<,>).MakeGenericType(messageType, contractType);
        var consumerManager = provider.GetRequiredService(consumerManagerType);
        
        var processorType = typeof(IDataProcessingManager<>).MakeGenericType(messageType);
        var dataProcessor = provider.GetRequiredService(processorType);
        
        var consumerServiceGeneric = TypeResolver.ResolveTypeOrFail(typeof(ConsumerService<,>).Assembly, "RCS.RabbitMq.Consumer.Services.ConsumerService`2");
        var consumerServiceType = consumerServiceGeneric.MakeGenericType(messageType, contractType);
        
        var loggerType = typeof(ILogger<>).MakeGenericType(consumerServiceType);
        var logger = provider.GetRequiredService(loggerType);
        
        var rabbitMqSettings = provider.GetRequiredService<RabbitMqSettings>();
        var consumerSettings = provider.GetRequiredService<ConsumerSettings>();
        var scalingCommands = provider.GetRequiredService<ConcurrentQueue<Action>>();
        var connection = provider.GetRequiredService<IConnection>();
        
        return Activator.CreateInstance(
                   consumerServiceType,
                   dataProcessor,
                   rabbitMqSettings,
                   consumerSettings,
                   scalingCommands,
                   logger,
                   connection,
                   consumerManager) as IHostedService
               ?? throw new InvalidOperationException($"Failed to create {consumerServiceType.Name}");
    }
    
    
    
    
    
    private static Type GetContractType(Type messageType)
    {
        return ContractTypeResolver.GetContractType(messageType);
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Factories\ConsumerSettingsLoader.cs

using Microsoft.Extensions.Configuration;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Consumer.Factories;




public class ConsumerSettingsLoader(IConfigurationIntegrityValidator integrityValidator) : ISettingsLoader<ConsumerSettings>
{
    
    
    
    
    
    
    
    public ConsumerSettings LoadSettings(IConfiguration configuration)
    {
        var section = configuration.GetSection("RCS.RabbitMQ.Consumer");
        
        integrityValidator.Validate(section);
        
        var serviceMappings = section.GetSection("ServiceMappings").GetChildren();
        
        var processorConfig = section.GetSection("ServiceMappings:Processor")
            .Get<Dictionary<string, string>>() 
            ?? throw new InvalidOperationException("No service mapping found for Processor.");
        
        var messageTypeSection = serviceMappings.Skip(1).FirstOrDefault()
            ?? throw new ArgumentException("No message type found in ServiceMappings.");
        var messageType = messageTypeSection.Key;
        
        var messageConfig = section.GetSection($"ServiceMappings:{messageType}")
            .Get<Dictionary<string, string>>() 
            ?? throw new InvalidOperationException($"No service mapping found for MessageType '{messageType}'.");
        
        var retVal = new ConsumerSettings
        {
            ProcessorAssembly = processorConfig.TryGetValue("ProcessorAssembly", out var processorAssembly)
                ? processorAssembly
                : throw new ArgumentException("'ProcessorAssembly' is missing for Processor."),
            ProcessorClass = processorConfig.TryGetValue("ProcessorClass", out var processorClass)
                ? processorClass
                : throw new ArgumentException("'ProcessorClass' is missing for Processor."),
            MessageType = messageType,
            MessageInterface = messageConfig.TryGetValue("MessageInterface", out var messageInterface)
                ? messageInterface
                : throw new ArgumentException($"'MessageInterface' is missing for MessageType '{messageType}'."),
            MessageClass = messageConfig.TryGetValue("MessageClass", out var messageClass)
                ? messageClass
                : throw new ArgumentException($"'MessageClass' is missing for MessageType '{messageType}'."),
            MessageMapper = messageConfig.TryGetValue("MessageMapper", out var messageMapper)
                ? messageMapper
                : throw new ArgumentException($"'MessageMapper' is missing for MessageType '{messageType}'."),
            MinConsumerCount = int.TryParse(section["MinConsumerCount"], out var minConsumerCount)
                ? minConsumerCount
                : throw new ArgumentException("'MinConsumerCount' is missing or invalid."),
            MaxConsumerCount = int.TryParse(section["MaxConsumerCount"], out var maxConsumerCount)
                ? maxConsumerCount
                : throw new ArgumentException("'MaxConsumerCount' is missing or invalid."),
            BatchSize = int.TryParse(section["BatchSize"], out var batchSize)
                ? batchSize
                : throw new ArgumentException("'BatchSize' is missing or invalid."),
            InactivityTrigger = int.TryParse(section["InactivityTrigger"], out var inactivityTrigger)
                ? inactivityTrigger
                : throw new ArgumentException("'InactivityTrigger' is missing or invalid."),
            NonRetryableExceptions = section.GetSection("NonRetryableExceptions").Get<string[]>()
                ?? throw new ArgumentException("'NonRetryableExceptions' is missing or invalid.")
        };
        return retVal;
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Factories\MonitoringServiceFactory.cs

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Consumer.Utilities;
namespace RCS.RabbitMq.Consumer.Factories;




public class MonitoringServiceFactory(IServiceProvider provider) : IMonitoringServiceFactory
{
    
    
    
    
    
    public void Create(Type messageType)
    {
        
        var contractType = GetContractType(messageType);
        
        var consumerManagerType = typeof(ConsumerManager<,>).MakeGenericType(messageType, contractType);
        var consumerManager = provider.GetRequiredService(consumerManagerType);
        
        var monitoringServiceGeneric = TypeResolver.ResolveTypeOrFail(
            typeof(MonitoringService<,>).Assembly,
            "RCS.RabbitMq.Consumer.Services.MonitoringService`2"
        );
        var monitoringServiceType = monitoringServiceGeneric.MakeGenericType(messageType, contractType);
        
        var loggerType = typeof(ILogger<>).MakeGenericType(monitoringServiceType);
        var logger = provider.GetRequiredService(loggerType);
        var rabbitMqSettings = provider.GetRequiredService<RabbitMqSettings>();
        
        _ = Activator.CreateInstance(
            monitoringServiceType,
            rabbitMqSettings,
            consumerManager,
            logger
        ) ?? throw new InvalidOperationException($"Failed to create {monitoringServiceType.Name}");
    }
    
    
    
    
    
    private static Type GetContractType(Type messageType)
    {
        return ContractTypeResolver.GetContractType(messageType);
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Factories\ProcessorSettingsLoader.cs

using Microsoft.Extensions.Configuration;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Shared.Services;
namespace RCS.RabbitMq.Consumer.Factories;



public class ProcessorSettingsLoader : ISettingsLoader<ProcessorSettings>
{
    
    
    
    
    
    
    public ProcessorSettings LoadSettings(IConfiguration configuration)
    {
        
        var consumerSettingsLoader = new ConsumerSettingsLoader(new ConfigurationIntegrityValidator());
        
        var consumerSettings = consumerSettingsLoader.LoadSettings(configuration);
        
        return new ProcessorSettings
        {
            ProcessorAssembly = consumerSettings.ProcessorAssembly,
            ProcessorClass = consumerSettings.ProcessorClass
        };
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Factories\RabbitMqSettingsLoader.cs

using Microsoft.Extensions.Configuration;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Consumer.Factories;





public class RabbitMqSettingsLoader(IConfigurationIntegrityValidator integrityValidator) : ISettingsLoader<RabbitMqSettings>
{
    private readonly IConfigurationIntegrityValidator _integrityValidator = integrityValidator ?? throw new ArgumentNullException(nameof(integrityValidator));
    
    
    
    
    
    
    public RabbitMqSettings LoadSettings(IConfiguration configuration)
    {
        
        var section = configuration.GetSection("RCS.RabbitMQ");
        
        _integrityValidator.Validate(section);
        
        var exchangeType = section["ExchangeType"] ?? throw new ArgumentException("'ExchangeType' is missing or null.");
        
        var routingKey = exchangeType == "fanout"
            ? null
            : section["RoutingKey"] ?? throw new ArgumentException("'RoutingKey' is missing or null.");
        return new RabbitMqSettings
        {
            Host = section["Host"] 
                ?? throw new ArgumentException("'Host' is missing or null."),
            Username = section["Username"] 
                ?? throw new ArgumentException("'Username' is missing or null."),
            Password = section["Password"] 
                ?? throw new ArgumentException("'Password' is missing or null."),
            ExchangeName = section["ExchangeName"] 
                ?? throw new ArgumentException("'ExchangeName' is missing or null."),
            ExchangeType = exchangeType,
            QueueName = section["QueueName"] 
                ?? throw new ArgumentException("'QueueName' is missing or null."),
            RoutingKey = routingKey,
            
            MessageTimeToLive = section["MessageTimeToLive"] != null
                ? int.TryParse(section["MessageTimeToLive"], out var messageTtl)
                    ? messageTtl
                    : throw new ArgumentException("'MessageTimeToLive' is not a valid integer.")
                : null,
            
            RetryQueueTimeToLive = int.TryParse(section["RetryQueueTimeToLive"], out var retryQueueTtl)
                ? retryQueueTtl
                : throw new ArgumentException("'RetryQueueTimeToLive' is missing, null, or not a valid integer."),
            
            MaxRetry = section["MaxRetry"] != null
                ? int.TryParse(section["MaxRetry"], out var maxRetry)
                    ? maxRetry
                    : throw new ArgumentException("'MaxRetry' is not a valid integer.")
                : null
        };
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Initialisation\RabbitMqHostedInitialiser.cs

using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using RCS.RabbitMq.Consumer.Interfaces;
namespace RCS.RabbitMq.Consumer.Initialisation;








public class RabbitMqHostedInitialiser(IRabbitMqInitialiser rabbitMqInitialiser, ILogger<RabbitMqHostedInitialiser> logger) : IHostedService
{
    
    
    
    
    public Task StartAsync(CancellationToken cancellationToken)
    {
        logger.LogInformation("Initialising RabbitMQ infrastructure...");
        rabbitMqInitialiser.InitialiseExchangeAndQueue();
        logger.LogInformation("RabbitMQ infrastructure initialised.");
        return Task.CompletedTask;
    }
    
    
    
    
    public Task StopAsync(CancellationToken cancellationToken) => Task.CompletedTask;
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Initialisation\RabbitMqInitialiser.cs

using Microsoft.Extensions.Logging;
using RabbitMQ.Client;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Models;
namespace RCS.RabbitMq.Consumer.Initialisation;










public class RabbitMqInitialiser(IModel channel, RabbitMqSettings rabbitMqSettings, ILogger<RabbitMqInitialiser> logger) : IRabbitMqInitialiser
{
    private readonly IModel _channel = channel ?? throw new ArgumentNullException(nameof(channel));
    private readonly RabbitMqSettings _rabbitMqSettings = rabbitMqSettings ?? throw new ArgumentNullException(nameof(rabbitMqSettings));
    
    
    
    
    public void InitialiseExchangeAndQueue()
    {
        try
        {
            logger.LogInformation("Starting RabbitMQ initialisation.");
            
            _channel.ExchangeDeclare(
                exchange: _rabbitMqSettings.ExchangeName.ToLower(),
                type: _rabbitMqSettings.ExchangeType.ToLower(),
                durable: true,
                autoDelete: false);
            
            var mainQueueArguments = new Dictionary<string, object> {
                { "x-dead-letter-exchange", _rabbitMqSettings.ExchangeName.ToLower() },
                { "x-dead-letter-routing-key", $"{_rabbitMqSettings.RoutingKey}_dead".ToLower() }
            };
            
            _channel.QueueDeclare(
                queue: $"{_rabbitMqSettings.QueueName}_main".ToLower(),
                durable: true,
                exclusive: false,
                autoDelete: false,
                arguments: mainQueueArguments);
            
            _channel.QueueBind(
                queue: $"{_rabbitMqSettings.QueueName}_main".ToLower(),
                exchange: _rabbitMqSettings.ExchangeName.ToLower(),
                routingKey: string.Equals(_rabbitMqSettings.ExchangeType, "fanout", StringComparison.OrdinalIgnoreCase) ? string.Empty : $"{_rabbitMqSettings.RoutingKey}_main".ToLower());
            
            var deadQueueArguments = new Dictionary<string, object>
            {
                { "x-dead-letter-exchange", _rabbitMqSettings.ExchangeName.ToLower() },
                { "x-dead-letter-routing-key", $"{_rabbitMqSettings.RoutingKey}_dead".ToLower() }
            };
            _channel.QueueDeclare(
                queue: $"{_rabbitMqSettings.QueueName}_dead".ToLower(),
                durable: true,
                exclusive: false,
                autoDelete: false,
                arguments: deadQueueArguments);
            _channel.QueueBind(
                queue: $"{_rabbitMqSettings.QueueName}_dead".ToLower(),
                exchange: _rabbitMqSettings.ExchangeName.ToLower(),
                routingKey: $"{_rabbitMqSettings.RoutingKey}_dead".ToLower());
            
            var retryQueueArguments = new Dictionary<string, object>
            {
                { "x-dead-letter-exchange", _rabbitMqSettings.ExchangeName.ToLower() },
                { "x-dead-letter-routing-key", $"{_rabbitMqSettings.RoutingKey}_main".ToLower() },
                { "x-message-ttl", _rabbitMqSettings.RetryQueueTimeToLive }
            };
            _channel.QueueDeclare(
                queue: $"{_rabbitMqSettings.QueueName}_retry".ToLower(),
                durable: true,
                exclusive: false,
                autoDelete: false,
                arguments: retryQueueArguments);
            _channel.QueueBind(
                queue: $"{_rabbitMqSettings.QueueName}_retry".ToLower(),
                exchange: _rabbitMqSettings.ExchangeName.ToLower(),
                routingKey: $"{_rabbitMqSettings.RoutingKey}_retry".ToLower());
            logger.LogInformation("RabbitMQ initialisation completed successfully.");
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error during RabbitMQ initialisation.");
            throw;
        }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Interfaces\IConsumerManager.cs

using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Consumer.Interfaces;





public interface IConsumerManager<TMessage, TContract>
    where TMessage : IAcknowledgeableRabbitMessage
    where TContract : IBasicMessageContract
{
    
    
    
    
    
    Task StartAsync(CancellationToken cancellationToken);
    
    
    
    
    
    Task StopAsync(CancellationToken cancellationToken);
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Interfaces\IConsumerService.cs

using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Consumer.Interfaces;





public interface IConsumerService<TMessage, TMappedMessage>
    where TMessage : class, IAcknowledgeableRabbitMessage, new()
    where TMappedMessage : class, IBasicMessageContract
{
    
    
    
    
    
    string? StartConsuming(CancellationToken cancellationToken);
    
    
    
    
    void StopConsuming(CancellationToken cancellationToken);
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Interfaces\IConsumerServiceFactory.cs

using Microsoft.Extensions.Hosting;
namespace RCS.RabbitMq.Consumer.Interfaces;



public interface IConsumerServiceFactory
{
    
    
    
    
    
    IHostedService Create(Type messageType);
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Interfaces\IDataProcessingManager.cs

namespace RCS.RabbitMq.Consumer.Interfaces;




public interface IDataProcessingManager<in T>
{
    
    
    
    
    
    
    
    
    Task<bool> ProcessBatchAsync(IEnumerable<T> messages);
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Interfaces\IMonitoringServiceFactory.cs

namespace RCS.RabbitMq.Consumer.Interfaces;



public interface IMonitoringServiceFactory
{
    
    
    
    
    void Create(Type messageType);
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Interfaces\IRabbitMqInitialiser.cs

namespace RCS.RabbitMq.Consumer.Interfaces;



public interface IRabbitMqInitialiser
{
    
    
    
    
    void InitialiseExchangeAndQueue();
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Interfaces\ISettingsLoader.cs

using Microsoft.Extensions.Configuration;
namespace RCS.RabbitMq.Consumer.Interfaces;




public interface ISettingsLoader<out T>
{
    
    
    
    
    
    
    
    
    
    
    
    T LoadSettings(IConfiguration configuration);
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Managers\ConsumerManager.cs

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using RabbitMQ.Client;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Services;
using RCS.RabbitMq.Shared.Interfaces;
using System.Collections.Concurrent;
namespace RCS.RabbitMq.Consumer.Managers;



public class ConsumerManager<TMessage, TMappedMessage> : IConsumerManager<TMessage, TMappedMessage>
    where TMessage : class, IAcknowledgeableRabbitMessage, new()
    where TMappedMessage : class, IBasicMessageContract
{
    private readonly ScalingCommandHandler _scalingCommandHandler;
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<ConsumerManager<TMessage, TMappedMessage>> _logger;
    private readonly ConcurrentDictionary<string, ConsumerService<TMessage, TMappedMessage>> _activeConsumers = new();
    private readonly System.Timers.Timer _scalingTimer;
    private readonly IRabbitMessageMapper<TMessage, TMappedMessage> _mapper;
    
    
    
    public ConsumerManager(
        ScalingCommandHandler scalingCommandHandler,
        IServiceProvider serviceProvider,
        ILogger<ConsumerManager<TMessage, TMappedMessage>> logger,
        IRabbitMessageMapper<TMessage, TMappedMessage> mapper)
    {
        _scalingCommandHandler = scalingCommandHandler ?? throw new ArgumentNullException(nameof(scalingCommandHandler));
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
        _scalingTimer = new System.Timers.Timer(1000);
        _scalingTimer.Elapsed += (_, _) => ExecuteScalingCommands();
        _scalingTimer.AutoReset = true;
        _scalingTimer.Start();
        _logger.LogInformation("ConsumerManager scaling timer started.");
    }
    
    public Task StartAsync(CancellationToken cancellationToken)
    {
        StartConsumer(cancellationToken);
        return Task.CompletedTask;
    }
    
    public Task StopAsync(CancellationToken cancellationToken)
    {
        StopConsumer(cancellationToken);
        return Task.CompletedTask;
    }
    
    
    
    public void StartConsumer(CancellationToken cancellationToken)
    {
        _scalingCommandHandler.AddCommand(() =>
        {
            if (cancellationToken.IsCancellationRequested)
            {
                _logger.LogInformation("StartConsumer canceled.");
                return;
            }
            try
            {
                var consumerService = CreateConsumerService();
                _mapper.Map(new TMessage());
                var consumerTag = consumerService.StartConsuming(cancellationToken);
                if (consumerTag == null) return;
                if (_activeConsumers.TryAdd(consumerTag, consumerService))
                {
                    _logger.LogInformation("Successfully registered consumer service for tag: {ConsumerTag}", consumerTag);
                }
                else
                {
                    _logger.LogWarning("Consumer service with tag: {ConsumerTag} is already registered.", consumerTag);
                }
                _logger.LogInformation("Consumer for {ConsumerTag} started successfully.", consumerTag);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error while starting consumer.");
            }
        });
    }
    
    
    
    public void StopConsumer(CancellationToken cancellationToken)
    {
        _scalingCommandHandler.AddCommand(() =>
        {
            if (cancellationToken.IsCancellationRequested)
            {
                _logger.LogInformation("StopConsumer was canceled.");
                return;
            }
            try
            {
                if (_activeConsumers.IsEmpty) return;
                var consumerToStop = _activeConsumers.First();
                if (_activeConsumers.TryGetValue(consumerToStop.Key, out var consumerObj))
                {
                    consumerObj.StopConsuming(cancellationToken);
                    _activeConsumers.TryRemove(consumerToStop.Key, out _);
                    _logger.LogInformation("Consumer with key {ConsumerKey} stopped successfully.", consumerToStop.Key);
                }
                else
                {
                    _logger.LogInformation("No active consumer found for type {ConsumerKey}.", consumerToStop.Key);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error stopping consumer.");
            }
        });
    }
    
    
    
    public void ExecuteScalingCommands()
    {
        _logger.LogTrace("Executing scaling commands.");
        _scalingCommandHandler.ExecuteCommands();
    }
    
    
    
    
    protected virtual ConsumerService<TMessage, TMappedMessage> CreateConsumerService()
    {
        return new ConsumerService<TMessage, TMappedMessage>(
            _serviceProvider.GetRequiredService<IDataProcessingManager<TMessage>>(),
            _serviceProvider.GetRequiredService<RabbitMqSettings>(),
            _serviceProvider.GetRequiredService<ConsumerSettings>(),
            _serviceProvider.GetRequiredService<ConcurrentQueue<Action>>(),
            _serviceProvider.GetRequiredService<ILogger<ConsumerService<TMessage, TMappedMessage>>>(),
            _serviceProvider.GetRequiredService<IConnection>(),
            this
        );
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Managers\ScalingCommandHandler.cs

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
namespace RCS.RabbitMq.Consumer.Managers;



public class ScalingCommandHandler
{
    private readonly ConcurrentQueue<Action> _scalingCommands = new();
    private readonly ILogger<ScalingCommandHandler> _logger;
    
    
    
    
    
    public ScalingCommandHandler(ILogger<ScalingCommandHandler> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
    
    
    
    
    
    public void AddCommand(Action command)
    {
        ArgumentNullException.ThrowIfNull(command);
        _scalingCommands.Enqueue(command);
        _logger.LogInformation("Scaling command added: {Command}.", StripGeneratedPart(command.Method.Name));
    }
    
    
    
    public void ExecuteCommands()
    {
        while (_scalingCommands.TryDequeue(out var command))
        {
            try
            {
                command();
                _logger.LogInformation("Scaling command executed successfully. Target Method: {Command}", StripGeneratedPart(command.Method.Name));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error executing scaling command. Target Method: {Command}", StripGeneratedPart(command.Method.Name));
            }
        }
    }
    
    
    
    
    
    private static string StripGeneratedPart(string methodName)
    {
        if (!methodName.Contains('<') || !methodName.Contains('>'))
        {
            return methodName;
        }
        return methodName[(methodName.IndexOf('<') + 1)..methodName.IndexOf('>')];
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Models\ConsumerSettings.cs

namespace RCS.RabbitMq.Consumer.Models;



public class ConsumerSettings
{
    
    
    
    public required string ProcessorAssembly { get; set; }
    
    
    
    public required string ProcessorClass { get; set; }
    
    
    
    public required string MessageType { get; set; }
    
    
    
    public required string MessageInterface { get; set; }
    
    
    
    public required string MessageClass { get; set; }
    
    
    
    public required string MessageMapper { get; set; }
    
    
    
    public required int MinConsumerCount { get; set; }
    
    
    
    public required int MaxConsumerCount { get; set; }
    
    
    
    
    public required int BatchSize { get; set; }
    
    
    
    public required int InactivityTrigger { get; set; }
    
    
    
    public required string[] NonRetryableExceptions { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Models\DiagnosticsData.cs

namespace RCS.RabbitMq.Consumer.Models;



public class DiagnosticsData
{
    
    
    
    public double CpuUsage { get; set; }
    
    
    
    public double OsUsedMemoryMb { get; set; }
    
    
    
    public double OsMemoryTotal { get; set; }
    
    
    
    public double OsMemoryUsagePercentage { get; set; }
    
    
    
    public double RabbitMqMemoryUsageMb { get; set; }
    
    
    
    public int Consumers { get; set; }
    
    
    
    public int Messages { get; set; }
    
    
    
    public int MessagesReady { get; set; }
    
    
    
    public int PublishedMessages { get; set; }
    
    
    
    public double DeliveredMessages { get; set; }
    
    
    
    public double AcknowledgedMessages { get; set; }
    
    
    
    public int UnacknowledgedMessages { get; set; }
    
    
    
    public double ConsumerCapacity { get; set; }
    
    
    
    public double ConsumerUtilisation { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Models\ProcessorSettings.cs

namespace RCS.RabbitMq.Consumer.Models;




public class ProcessorSettings
{
    
    
    
    public required string ProcessorAssembly { get; set; }
    
    
    
    public required string ProcessorClass { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Models\RabbitMqSettings.cs

namespace RCS.RabbitMq.Consumer.Models;



public class RabbitMqSettings
{
    
    
    
    public required string Host { get; set; }
    
    
    
    public required string Username { get; set; }
    
    
    
    public required string Password { get; set; }
    
    
    
    public required string ExchangeName { get; set; }
    
    
    
    public required string ExchangeType { get; set; }
    
    
    
    public required string QueueName { get; set; }
    
    
    
    public string? RoutingKey { get; set; }
    
    
    
    
    public int? MessageTimeToLive { get; set; }
    
    
    
    
    public int RetryQueueTimeToLive { get; set; }
    
    
    
    public int? MaxRetry { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs


using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\obj\Debug\net8.0\RCS.RabbitMq.Consumer.AssemblyInfo.cs










using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("RCS.RabbitMq.Consumer")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+2594265be2391f1e070532a69fc43dac0a1571ab")]
[assembly: System.Reflection.AssemblyProductAttribute("RCS.RabbitMq.Consumer")]
[assembly: System.Reflection.AssemblyTitleAttribute("RCS.RabbitMq.Consumer")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\obj\Debug\net8.0\RCS.RabbitMq.Consumer.GlobalUsings.g.cs


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\obj\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs


using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\obj\Release\net8.0\RCS.RabbitMq.Consumer.AssemblyInfo.cs










using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("RCS.RabbitMq.Consumer")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+272336a1c31f127b005c183e51da8542e1f028e2")]
[assembly: System.Reflection.AssemblyProductAttribute("RCS.RabbitMq.Consumer")]
[assembly: System.Reflection.AssemblyTitleAttribute("RCS.RabbitMq.Consumer")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\obj\Release\net8.0\RCS.RabbitMq.Consumer.GlobalUsings.g.cs


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Processing\DataProcessingManager.cs

using Microsoft.Extensions.Logging;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Models;
using System.Reflection;
namespace RCS.RabbitMq.Consumer.Processing;




public class DataProcessingManager<T> : IDataProcessingManager<T>
{
    private readonly ProcessorSettings _processorSettings;
    private readonly ILogger<DataProcessingManager<T>> _logger;
    private readonly Func<IEnumerable<T>, bool> _processDelegate;
    
    
    
    
    
    
    public DataProcessingManager(ProcessorSettings processorSettings, ILogger<DataProcessingManager<T>> logger)
    {
        _processorSettings = processorSettings ?? throw new ArgumentNullException(nameof(processorSettings));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        
        _processDelegate = InitialiseProcessDelegate();
    }
    
    
    
    
    
    private Func<IEnumerable<T>, bool> InitialiseProcessDelegate()
    {
        try
        {
            
            var processorAssembly = ProcessorCache.LoadAssemblyWithCache(_processorSettings.ProcessorAssembly);
            var processorType = ProcessorCache.GetProcessorType(processorAssembly, _processorSettings.ProcessorClass);
            
            var processMethod = processorType.GetMethod("Process", BindingFlags.Static | BindingFlags.Public) ?? throw new InvalidOperationException("Static method 'Process' not found on the processor.");
            if (!processMethod.IsGenericMethodDefinition)
            {
                throw new InvalidOperationException("Method 'Process' is not a generic method.");
            }
            
            var genericMethod = processMethod.MakeGenericMethod(typeof(T));
            return (Func<IEnumerable<T>, bool>)Delegate.CreateDelegate(typeof(Func<IEnumerable<T>, bool>), genericMethod);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialise Process delegate.");
            throw;
        }
    }
    
    
    
    
    
    public Task<bool> ProcessBatchAsync(IEnumerable<T> messages)
    {
        try
        {
            
            var success = _processDelegate(messages);
            
            _logger.LogDebug("Batch processed successfully: {Success}", success);
            return Task.FromResult(success);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error occurred during batch processing.");
            return Task.FromException<bool>(ex);
        }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Processing\ProcessorCache.cs

using System.Collections.Concurrent;
using System.Reflection;
namespace RCS.RabbitMq.Consumer.Processing;



public static class ProcessorCache
{
    
    
    
    public static readonly ConcurrentDictionary<string, Type> TypeCache = new();
    
    
    
    public static readonly ConcurrentDictionary<string, Assembly> AssemblyCache = new();
    
    
    
    
    
    public static Assembly LoadAssemblyWithCache(string assemblyPath)
    {
        return AssemblyCache.GetOrAdd(assemblyPath, path =>
        {
            var fullPath = Path.Combine(AppContext.BaseDirectory, path);
            return Assembly.LoadFrom(fullPath);
        });
    }
    
    
    
    
    
    
    
    public static Type GetProcessorType(Assembly assembly, string className)
    {
        return TypeCache.GetOrAdd(className, name =>
        {
            return assembly.GetTypes().FirstOrDefault(t => string.Equals(t.FullName, name, StringComparison.OrdinalIgnoreCase))
                   ?? throw new InvalidOperationException($"Type '{name}' not found in assembly '{assembly.FullName}'.");
        });
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Services\ConsumerService.cs

using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using RCS.RabbitMq.Consumer.Interfaces;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Utilities;
using RCS.RabbitMq.Shared.Interfaces;
using System.Collections.Concurrent;
using System.Text;
using System.Text.Json;
namespace RCS.RabbitMq.Consumer.Services;



public class ConsumerService<TMessage, TMappedMessage>(
    IDataProcessingManager<TMessage> dataProcessingManager,
    RabbitMqSettings rabbitMqSettings,
    ConsumerSettings consumerSettings,
    ConcurrentQueue<Action> scalingCommands,
    ILogger<ConsumerService<TMessage, TMappedMessage>> logger,
    IConnection connection,
    ConsumerManager<TMessage, TMappedMessage> consumerManager)
    : BackgroundService, IConsumerService<TMessage, TMappedMessage>
    where TMessage : class, IAcknowledgeableRabbitMessage, new()
    where TMappedMessage : class, IBasicMessageContract
{
    private readonly ILogger<ConsumerService<TMessage, TMappedMessage>> _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    private readonly IDataProcessingManager<TMessage> _dataProcessingManager = dataProcessingManager ?? throw new ArgumentNullException(nameof(dataProcessingManager));
    private readonly RabbitMqSettings _rabbitMqSettings = rabbitMqSettings ?? throw new ArgumentNullException(nameof(rabbitMqSettings));
    private readonly ConsumerSettings _consumerSettings = consumerSettings ?? throw new ArgumentNullException(nameof(consumerSettings));
    private readonly ConcurrentQueue<Action> _scalingCommands = scalingCommands ?? throw new ArgumentNullException(nameof(scalingCommands));
    private readonly IConnection _connection = connection ?? throw new ArgumentNullException(nameof(connection));
    private readonly ConsumerManager<TMessage, TMappedMessage> _consumerManager = consumerManager ?? throw new ArgumentNullException(nameof(consumerManager));
    private readonly ConcurrentDictionary<string, IModel> _activeChannels = new();
    private readonly SemaphoreSlim _deliveryTagsSemaphore = new(1, 1);
    
    
    
    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        for (var i = 1; i < _consumerSettings.MinConsumerCount; i++)
        {
            await Task.Run(() => { _consumerManager.StartConsumer(cancellationToken); }, cancellationToken);
        }
        await MonitorScalingCommandsAsync(cancellationToken);
    }
    
    
    
    protected virtual async Task HandleMessageAsync(TMessage message, CancellationToken cancellationToken)
    {
        await _dataProcessingManager.ProcessBatchAsync([message]);
    }
    
    
    
    protected virtual Task<bool> ProcessBatchAsync(IEnumerable<TMessage> messages)
    {
        return _dataProcessingManager.ProcessBatchAsync(messages);
    }
    
    
    
    private async Task MonitorScalingCommandsAsync(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            if (_scalingCommands.TryDequeue(out var command))
            {
                command();
            }
            await Task.Delay(1000, cancellationToken);
        }
    }
    
    
    
    public virtual string? StartConsuming(CancellationToken cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            _logger.LogInformation("Starting consumer canceled.");
            return null;
        }
        var channel = _connection.CreateModel();
        var consumerQueue = new ConcurrentQueue<TMessage>();
        var deliveryTagsToAck = new ConcurrentDictionary<ulong, byte>();
        var semaphore = new SemaphoreSlim(1, 1);
        
        var flushTimer = new System.Timers.Timer(_consumerSettings.InactivityTrigger * 1000)
        {
            AutoReset = true,
            Enabled = true
        };
        flushTimer.Elapsed += async (_, _) =>
        {
            if (!await semaphore.WaitAsync(0, cancellationToken)) return;
            try { await PrepareBatchAsync(consumerQueue, deliveryTagsToAck, channel); }
            finally { semaphore.Release(); }
        };
        var consumer = new AsyncEventingBasicConsumer(channel);
        consumer.Received += async (_, ea) =>
        {
            flushTimer.Stop(); flushTimer.Start();
            deliveryTagsToAck.TryAdd(ea.DeliveryTag, 0);
            if (cancellationToken.IsCancellationRequested)
            {
                channel.BasicNack(ea.DeliveryTag, false, true);
                return;
            }
            var message = DeserializeMessage(ea.Body);
            if (message == null)
            {
                var deadLetterMessage = new TMessage
                {
                    DeliveryTag = ea.DeliveryTag,
                    Headers = ea.BasicProperties.Headers ?? new Dictionary<string, object> { { "Reason", "Deserialization Failure" } }
                };
                MoveToDeadLetterQueue(deadLetterMessage, channel);
                return;
            }
            message.DeliveryTag = ea.DeliveryTag;
            consumerQueue.Enqueue(message);
            if (consumerQueue.Count >= _consumerSettings.BatchSize)
            {
                if (await semaphore.WaitAsync(0, cancellationToken))
                {
                    try { await PrepareBatchAsync(consumerQueue, deliveryTagsToAck, channel); deliveryTagsToAck.Clear(); }
                    finally { semaphore.Release(); }
                }
            }
        };
        var consumerTag = $"{_rabbitMqSettings.QueueName}_main_consumer_{Guid.NewGuid()}";
        if (!_activeChannels.TryAdd(consumerTag, channel))
        {
            _logger.LogWarning("Failed to add channel for ConsumerTag: {ConsumerTag}", consumerTag);
            throw new InvalidOperationException($"Failed to add channel for ConsumerTag: {consumerTag}");
        }
        channel.BasicConsume(
            queue: $"{_rabbitMqSettings.QueueName}_main".ToLower(),
            autoAck: false,
            consumerTag: consumerTag,
            consumer: consumer);
        _logger.LogInformation("Consumer started with tag: {ConsumerTag}", consumerTag);
        return consumerTag;
    }
    
    
    
    public void StopConsuming(CancellationToken cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            _logger.LogInformation("Stopping consuming for {ConsumerType} canceled.", typeof(TMessage).Name);
            return;
        }
        if (_activeChannels.IsEmpty)
        {
            _logger.LogWarning("No active consumers to stop.");
            return;
        }
        var consumerTag = _activeChannels.Keys.LastOrDefault();
        if (consumerTag == null)
        {
            _logger.LogWarning("No consumer tag found in active channels.");
            return;
        }
        if (_activeChannels.TryRemove(consumerTag, out var channel))
        {
            try { channel.Close(); channel.Dispose(); }
            catch (Exception ex) { _logger.LogError(ex, "Error while stopping consumer with tag {ConsumerTag}.", consumerTag); }
        }
        _logger.LogDebug("Remaining Active Channels: {ActiveChannels}", string.Join(", ", _activeChannels.Keys));
    }
    
    
    
    private async Task PrepareBatchAsync(ConcurrentQueue<TMessage> messageQueue, ConcurrentDictionary<ulong, byte> deliveryTags, IModel channel)
    {
        var messagesToProcess = new List<TMessage>();
        try
        {
            await _deliveryTagsSemaphore.WaitAsync();
            
            while (messageQueue.TryDequeue(out var message))
            {
                if (deliveryTags.TryRemove(message.DeliveryTag, out _))
                {
                    messagesToProcess.Add(message);
                }
            }
            
            if (messagesToProcess.Count > 0)
            {
                try
                {
                    var processingSuccessful = await _dataProcessingManager.ProcessBatchAsync(messagesToProcess);
                    if (processingSuccessful)
                    {
                        var lastDeliveryTag = messagesToProcess[^1].DeliveryTag;
                        channel.BasicAck(lastDeliveryTag, true);
                    }
                    else
                    {
                        foreach (var message in messagesToProcess)
                        {
                            HandleError(message, new Exception("Message failed"), channel);
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Batch processing failed. Handling messages individually.");
                    foreach (var message in messagesToProcess)
                    {
                        HandleError(message, ex, channel);
                    }
                }
            }
        }
        finally
        {
            _deliveryTagsSemaphore.Release();
        }
    }
    
    
    
    private void HandleError(TMessage message, Exception ex, IModel channel)
    {
        try
        {
            if (ex is SqlException or TimeoutException)
            {
                RetryOrDeadLetter(message, channel);
            }
            else
            {
                MoveToDeadLetterQueue(message, channel);
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e, "An error occurred while executing 'HandleError'.");
        }
    }
    
    
    
    private void RetryOrDeadLetter(TMessage message, IModel channel)
    {
        try
        {
            var headers = message.Headers ?? new Dictionary<string, object>();
            var xDeathCount = GetXDeathCount(headers);
            if (xDeathCount < _rabbitMqSettings.MaxRetry || !_rabbitMqSettings.MaxRetry.HasValue)
            {
                RequeueMessage(message, channel);
            }
            else
            {
                MoveToDeadLetterQueue(message, channel);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while executing 'RetryOrDeadLetter'.");
            channel.BasicNack(message.DeliveryTag, false, false);
        }
    }
    
    
    
    private void RequeueMessage(TMessage message, IModel channel)
    {
        try
        {
            channel.BasicAck(message.DeliveryTag, false);
            var newProperties = channel.CreateBasicProperties();
            newProperties.Persistent = true;
            newProperties.ContentType = "application/json";
            newProperties.Headers = new Dictionary<string, object>(message.Headers ?? new Dictionary<string, object>());
            var messageBody = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(message));
            channel.BasicPublish(
                exchange: _rabbitMqSettings.ExchangeName,
                routingKey: $"{_rabbitMqSettings.RoutingKey}_retry",
                basicProperties: newProperties,
                body: messageBody);
            _logger.LogInformation("Requeued message with DeliveryTag {DeliveryTag}.", message.DeliveryTag);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while executing 'RequeueMessage'.");
            channel.BasicNack(message.DeliveryTag, false, false);
        }
    }
    
    
    
    private void MoveToDeadLetterQueue(TMessage message, IModel channel)
    {
        try
        {
            var messageBody = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(message));
            var properties = channel.CreateBasicProperties();
            properties.Persistent = true;
            properties.ContentType = "application/json";
            channel.BasicPublish(
                exchange: _rabbitMqSettings.ExchangeName,
                routingKey: $"{_rabbitMqSettings.RoutingKey}_dead",
                basicProperties: properties,
                body: messageBody);
            channel.BasicAck(message.DeliveryTag, false);
            _logger.LogInformation("Moved message with DeliveryTag {DeliveryTag} to dead-letter queue.", message.DeliveryTag);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while executing 'MoveToDeadLetterQueue'.");
            channel.BasicNack(message.DeliveryTag, false, false);
        }
    }
    
    
    
    private static int GetXDeathCount(IDictionary<string, object> headers)
    {
        if (!headers.TryGetValue("x-death", out var xDeathHeader) || xDeathHeader is not IList<object> xDeathList)
        {
            return 0;
        }
        if (xDeathList.Count == 0 || xDeathList[0] is not Dictionary<string, object> xDeathEntry)
        {
            return 0;
        }
        if (xDeathEntry.TryGetValue("count", out var count) && count is long countValue)
        {
            return (int)countValue;
        }
        return 0;
    }
    
    
    
    private static TMessage? DeserializeMessage(ReadOnlyMemory<byte> messageBody)
    {
        try
        {
            return JsonSerializer.Deserialize<TMessage>(messageBody.Span, JsonSerializerOptionsCache.Options);
        }
        catch
        {
            return null;
        }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Services\MonitoringService.cs

using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using RCS.RabbitMq.Consumer.Dtos;
using RCS.RabbitMq.Consumer.Managers;
using RCS.RabbitMq.Consumer.Models;
using RCS.RabbitMq.Consumer.Utilities;
using RCS.RabbitMq.Shared.Interfaces;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Management;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Text.Json;
namespace RCS.RabbitMq.Consumer.Services;
public class MonitoringService<TMessage, TMappedMessage> : BackgroundService
    where TMessage : class, IAcknowledgeableRabbitMessage, new()
    where TMappedMessage : class, IBasicMessageContract
{
    private readonly PerformanceCounter? _cpuCounter;
    private readonly PerformanceCounter? _memoryCounter;
    private readonly RabbitMqSettings _rabbitMqSettings;
    private readonly HttpClient _httpClient;
    private readonly ConsumerManager<TMessage, TMappedMessage> _consumerManager;
    private readonly ConcurrentQueue<DiagnosticsData> _mainQueueDiagnosticsData = new();
    private readonly ILogger<MonitoringService<TMessage, TMappedMessage>> _logger;
    private const int MovingAveragePeriod = 5;
    private const int DiagnosticsReadInterval = 60;
    private bool _hasStarted;
    public MonitoringService(RabbitMqSettings rabbitMqSettings,
        ConsumerManager<TMessage, TMappedMessage> consumerManager,
        ILogger<MonitoringService<TMessage, TMappedMessage>> logger)
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            throw new PlatformNotSupportedException("'MonitoringService' is only supported on Windows.");
        }
        _rabbitMqSettings = rabbitMqSettings ?? throw new ArgumentNullException(nameof(rabbitMqSettings));
        _consumerManager = consumerManager ?? throw new ArgumentNullException(nameof(consumerManager));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
        _memoryCounter = new PerformanceCounter("Memory", "Available MBytes");
        _httpClient = new HttpClient
        {
            BaseAddress = new Uri($"http:
        };
        var byteArray = System.Text.Encoding.ASCII.GetBytes($"{_rabbitMqSettings.Username}:{_rabbitMqSettings.Password}");
        _httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Basic", Convert.ToBase64String(byteArray));
    }
    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        try
        {
            _consumerManager.StartConsumer(cancellationToken);
            while (!cancellationToken.IsCancellationRequested)
            {
                var mainQueueInfo = await GetQueueInfo($"{_rabbitMqSettings.QueueName}_main".ToLower(), cancellationToken);
                if (_hasStarted)
                {
                    var cpuUsage = 0.0;
                    var osMemoryTotal = 0.0;
                    var osUsedMemoryMb = 0.0;
                    var osMemoryUsagePercentage = 0.0;
                    if (OperatingSystem.IsWindows())
                    {
                        cpuUsage = GetCpuUsage();
                        osMemoryTotal = GetTotalMemoryInMb() ?? 0.0;
                        GetOsMemoryUsage(out osUsedMemoryMb, out osMemoryUsagePercentage);
                    }
                    if (mainQueueInfo != null)
                    {
                        var mainQueueDiagnosticsData = new DiagnosticsData
                        {
                            CpuUsage = cpuUsage,
                            OsUsedMemoryMb = osUsedMemoryMb,
                            OsMemoryTotal = osMemoryTotal,
                            OsMemoryUsagePercentage = osMemoryUsagePercentage,
                            RabbitMqMemoryUsageMb = GetRabbitMqMemoryUsage(mainQueueInfo),
                            Consumers = GetConsumers(mainQueueInfo),
                            Messages = GetMessages(mainQueueInfo),
                            MessagesReady = GetMessagesReady(mainQueueInfo),
                            PublishedMessages = GetPublishedMessages(mainQueueInfo),
                            DeliveredMessages = GetDeliveredMessages(mainQueueInfo),
                            AcknowledgedMessages = GetAcknowledgedMessages(mainQueueInfo),
                            UnacknowledgedMessages = GetMessagesUnacknowledged(mainQueueInfo),
                            ConsumerCapacity = GetConsumerCapacity(mainQueueInfo),
                            ConsumerUtilisation = GetConsumerUtilisation(mainQueueInfo)
                        };
                        AddDiagnosticsDataToQueue(mainQueueDiagnosticsData);
                        if (_mainQueueDiagnosticsData.Count >= MovingAveragePeriod)
                        {
                            await EvaluateScalingNeeds(mainQueueDiagnosticsData, cancellationToken);
                        }
                    }
                    else
                    {
                        _logger.LogInformation("'QueueInfo' is null");
                    }
                }
                await Task.Delay(TimeSpan.FromSeconds(DiagnosticsReadInterval), cancellationToken);
                if (mainQueueInfo != null)
                {
                    _hasStarted = true;
                }
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("MonitoringService was canceled.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in ExecuteAsync: {ErrorMessage}", ex.Message);
            throw;
        }
        finally
        {
            _consumerManager.StopConsumer(cancellationToken);
        }
    }
    private void AddDiagnosticsDataToQueue(DiagnosticsData mainQueueDiagnosticsData)
    {
        while (_mainQueueDiagnosticsData.Count >= MovingAveragePeriod)
        {
            _mainQueueDiagnosticsData.TryDequeue(out _);
        }
        _mainQueueDiagnosticsData.Enqueue(mainQueueDiagnosticsData);
    }
    private DiagnosticsData GetAverageDiagnosticsData()
    {
        var dataPoints = _mainQueueDiagnosticsData.ToArray();
        if (dataPoints.Length == 0)
        {
            return new DiagnosticsData();
        }
        return new DiagnosticsData
        {
            CpuUsage = dataPoints.Average(d => d.CpuUsage),
            OsUsedMemoryMb = dataPoints.Average(d => d.OsUsedMemoryMb),
            OsMemoryUsagePercentage = dataPoints.Average(d => d.OsMemoryUsagePercentage),
            RabbitMqMemoryUsageMb = dataPoints.Average(d => d.RabbitMqMemoryUsageMb),
            Consumers = (int)dataPoints.Average(d => d.Consumers),
            Messages = (int)dataPoints.Average(d => d.Messages),
            MessagesReady = (int)dataPoints.Average(d => d.MessagesReady),
            PublishedMessages = (int)dataPoints.Average(d => d.PublishedMessages),
            DeliveredMessages = dataPoints.Average(d => d.DeliveredMessages),
            AcknowledgedMessages = dataPoints.Average(d => d.AcknowledgedMessages),
            UnacknowledgedMessages = (int)dataPoints.Average(d => d.UnacknowledgedMessages),
            ConsumerCapacity = dataPoints.Average(d => d.ConsumerCapacity),
            ConsumerUtilisation = dataPoints.Average(d => d.ConsumerUtilisation)
        };
    }
    private async Task EvaluateScalingNeeds(DiagnosticsData mainQueueDiagnosticsData, CancellationToken cancellationToken)
    {
        var averageData = GetAverageDiagnosticsData();
        if (averageData.MessagesReady == 0 && (averageData.AcknowledgedMessages != 0 && averageData.DeliveredMessages != 0))
        {
            return;
        }
        if (averageData.DeliveredMessages > averageData.AcknowledgedMessages && averageData.MessagesReady > 0 && averageData.ConsumerCapacity * 100 < 50.00)
        {
            if (mainQueueDiagnosticsData.Consumers == 50)
            {
                return;
            }
            _logger.LogInformation("High load detected. Adding a new consumer.");
            await Task.Run(() =>
            {
                _consumerManager.StartConsumer(cancellationToken);
            }, cancellationToken);
        }
        else if (averageData.DeliveredMessages <= averageData.AcknowledgedMessages && averageData.ConsumerCapacity * 100 > 80.00 && averageData.UnacknowledgedMessages == 0)
        {
            if (mainQueueDiagnosticsData.Consumers == 1)
            {
                return;
            }
            _logger.LogInformation("Low load detected. Removing a consumer.");
            _consumerManager.StopConsumer(cancellationToken);
        }
    }
    private static int GetMessages(Root? mainQueueInfo) => mainQueueInfo?.Messages ?? 0;
    private static int GetMessagesReady(Root? mainQueueInfo) => mainQueueInfo?.MessagesReady ?? 0;
    private static int GetMessagesUnacknowledged(Root? mainQueueInfo) => mainQueueInfo?.MessagesUnacknowledged ?? 0;
    private static int GetPublishedMessages(Root? mainQueueInfo) => mainQueueInfo?.MessageStats.Publish ?? 0;
    private static double GetConsumerCapacity(Root? mainQueueInfo) => mainQueueInfo?.ConsumerCapacity ?? 0.0;
    private static double GetConsumerUtilisation(Root? mainQueueInfo) => mainQueueInfo?.ConsumerUtilisation ?? 0.0;
    private static int GetConsumers(Root? mainQueueInfo) => mainQueueInfo?.Consumers ?? 0;
    private static double GetRabbitMqMemoryUsage(Root? mainQueueInfo) => (mainQueueInfo?.Memory ?? 0.0) / (1024 * 1024);
    [SupportedOSPlatform("windows")]
    private void GetOsMemoryUsage(out double osUsedMemoryMb, out double osMemoryUsagePercentage)
    {
        try
        {
            var availableMemory = _memoryCounter?.NextValue() ?? 0.0;
            var totalMemory = GetTotalMemoryInMb() ?? 0.0;
            osUsedMemoryMb = totalMemory - availableMemory;
            osMemoryUsagePercentage = (osUsedMemoryMb / totalMemory) * 100;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving OS memory usage: {ErrorMessage}", ex.Message);
            osUsedMemoryMb = 0.0;
            osMemoryUsagePercentage = 0.0;
        }
    }
    private static double GetDeliveredMessages(Root? mainQueueInfo) => mainQueueInfo?.MessageStats.DeliverGetDetails.Rate ?? 0;
    private static double GetAcknowledgedMessages(Root? mainQueueInfo) => mainQueueInfo?.MessageStats.AckDetails.Rate ?? 0;
    [SupportedOSPlatform("windows")]
    private double GetCpuUsage()
    {
        try
        {
            return _cpuCounter?.NextValue() ?? 0.0;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving CPU usage: {ErrorMessage}", ex.Message);
            return 0.0;
        }
    }
    [SupportedOSPlatform("windows")]
    private double? GetTotalMemoryInMb()
    {
        try
        {
            var searcher = new ManagementObjectSearcher("SELECT TotalPhysicalMemory FROM Win32_ComputerSystem");
            foreach (var obj in searcher.Get())
            {
                if (obj["TotalPhysicalMemory"] is ulong memoryBytes)
                {
                    return memoryBytes / (1024.0 * 1024.0);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving total memory: {ErrorMessage}", ex.Message);
        }
        return null;
    }
    private async Task<Root?> GetQueueInfo(string queueName, CancellationToken cancellationToken)
    {
        try
        {
            var response = await _httpClient.GetStringAsync($"queues/%2f/{queueName}", cancellationToken);
            return JsonSerializer.Deserialize<Root>(response, JsonSerializerOptionsCache.Options); 
        }
        catch (JsonException)
        {
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving queue info: {ErrorMessage}", ex.Message);
            return null;
        }
    }
    public override void Dispose()
    {
        _cpuCounter?.Dispose();
        _memoryCounter?.Dispose();
        GC.SuppressFinalize(this);
        base.Dispose();
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Utilities\ContractTypeResolver.cs

using System.Reflection;
namespace RCS.RabbitMq.Consumer.Utilities;



public static class ContractTypeResolver
{
    
    
    
    
    
    
    public static Type GetContractType(Type messageType)
    {
        var baseDirectory = AppContext.BaseDirectory;
        
        var assemblyFiles = Directory.GetFiles(baseDirectory, "RCS.RabbitMQ.*.dll");
        foreach (var file in assemblyFiles)
        {
            var assembly = Assembly.LoadFrom(file);
            
            var contractType = assembly.GetTypes().FirstOrDefault(type =>
                type.IsInterface && type.IsAssignableFrom(messageType));
            if (contractType != null)
            {
                return contractType;
            }
        }
        throw new InvalidOperationException($"Unknown message contract type for message: {messageType.Name}");
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Utilities\JsonSerializerOptionsCache.cs

using System.Text.Json;
namespace RCS.RabbitMq.Consumer.Utilities;



public static class JsonSerializerOptionsCache
{
    
    
    
    
    
    public static readonly JsonSerializerOptions Options = new()
    {
        PropertyNameCaseInsensitive = true,
        DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
    };
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Utilities\TypeResolver.cs

using System.Reflection;
namespace RCS.RabbitMq.Consumer.Utilities;



public static class TypeResolver
{
    
    
    
    
    
    
    
    
    
    public static Type ResolveTypeOrFail(Assembly assembly, string typeName)
    {
        try
        {
            return assembly.GetType(typeName, throwOnError: true)
                   ?? throw new InvalidOperationException($"Type '{typeName}' not found in assembly '{assembly.FullName}'.");
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException(
                $"Failed to resolve type '{typeName}' from assembly '{assembly.FullName}'. Check your configuration.",
                ex);
        }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Consumer\appsettings.DEV.json

{
  "RCS.RabbitMQ": {
    //"Host": "localhost",
    //"Username": "guest",
    //"Password": "guest",
    //"ExchangeName": "whatsapp",
    //"ExchangeType": "direct",
    //"QueueName": "whatsapp",
    //"RoutingKey": "whatsapp",
    //"MessageTimeToLive": 3600000,
    //"RetryQueueTimeToLive": 300,
    //"MaxRetry": 3

    "Host": "rcscptdappws10",
    // update rabbbit server to use svc_rabbitmqloggingD instead of svc_rabbitmqlogging_d
    "Username": "svc_rabbitmqlogging_d",
    // use the password from password manager vV5pNE£'E^^$"Q595=£YJ*#a<"Dk==3-/ -- figure out how to handle non compliant json values
    "Password": "svc_rabbitmqlogging_d",
    "ExchangeName": "rabbitmq_logging",
    "ExchangeType": "direct",
    "QueueName": "rabbitmq_logging",
    "RoutingKey": "rabbitmq_logging",
    "MessageTimeToLive": 3600000,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Consumer\appsettings.json

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "Debug"
      },
      {
        "Name": "File",
        "Args": {
          "Path": "C:/Logs/RabbitMq/Consumers/Logging/RCS.RabbitMq.Logging.Consumer.txt",
          "RollingInterval": "Day"
        }
      }
    ]
  },
  "RCS.RabbitMQ.Consumer": {
    "ServiceMappings": {
      "Processor": {
        "ProcessorAssembly": "RCS.RabbitMq.Logging.Processor.dll",
        "ProcessorClass": "RCS.RabbitMq.Logging.Processor.ProcessMessages"
      },
      "WhatsAppMessage": {
        "MessageInterface": "RCS.RabbitMq.Logging.Processor.Interfaces.ILogMessage",
        "MessageClass": "RCS.RabbitMq.Logging.Processor.Models.LogMessage",
        "MessageMapper": "RCS.RabbitMq.Logging.Processor.Models.LogMessageMapper"
      }
    },
    "MinConsumerCount": 10,
    "MaxConsumerCount": 50,
    "BatchSize": 2500,
    "InactivityTrigger": 10,
    "NonRetryableExceptions": [
      "System.ArgumentException",
      "System.InvalidOperationException",
      "System.NullReferenceException",
      "System.FormatException",
      "System.NotSupportedException"
    ]
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Consumer\appsettings.PROD.json

{
  "RCS.RabbitMQ": {
    //"Host": "localhost",
    //"Username": "guest",
    //"Password": "guest",
    //"ExchangeName": "whatsapp",
    //"ExchangeType": "direct",
    //"QueueName": "whatsapp",
    //"RoutingKey": "whatsapp",
    //"MessageTimeToLive": 3600000,
    //"RetryQueueTimeToLive": 300,
    //"MaxRetry": 3,

    "Host": "rcscptdappws10",
    // update rabbbit server to use svc_rabbitmqloggingD instead of svc_rabbitmqlogging_d
    "Username": "svc_rabbitmqlogging_d",
    // use the password from password manager vV5pNE£'E^^$"Q595=£YJ*#a<"Dk==3-/ -- figure out how to handle non compliant json values
    "Password": "svc_rabbitmqlogging_d",
    "ExchangeName": "rabbitmq_logging",
    "ExchangeType": "direct",
    "QueueName": "rabbitmq_logging",
    "RoutingKey": "rabbitmq_logging",
    "MessageTimeToLive": 3600000,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Consumer\appsettings.SIT.json

{
  "RCS.RabbitMQ": {
    //"Host": "localhost",
    //"Username": "guest",
    //"Password": "guest",
    //"ExchangeName": "whatsapp",
    //"ExchangeType": "direct",
    //"QueueName": "whatsapp",
    //"RoutingKey": "whatsapp",
    //"MessageTimeToLive": 3600000,
    //"RetryQueueTimeToLive": 300,
    //"MaxRetry": 3,

    "Host": "rcscptdappws10",
    // update rabbbit server to use svc_rabbitmqloggingD instead of svc_rabbitmqlogging_d
    "Username": "svc_rabbitmqlogging_d",
    // use the password from password manager vV5pNE£'E^^$"Q595=£YJ*#a<"Dk==3-/ -- figure out how to handle non compliant json values
    "Password": "svc_rabbitmqlogging_d",
    "ExchangeName": "rabbitmq_logging",
    "ExchangeType": "direct",
    "QueueName": "rabbitmq_logging",
    "RoutingKey": "rabbitmq_logging",
    "MessageTimeToLive": 3600000,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Consumer\appsettings.UAT.json

{
  "RCS.RabbitMQ": {
    //"Host": "localhost",
    //"Username": "guest",
    //"Password": "guest",
    //"ExchangeName": "whatsapp",
    //"ExchangeType": "direct",
    //"QueueName": "whatsapp",
    //"RoutingKey": "whatsapp",
    //"MessageTimeToLive": 3600000,
    //"RetryQueueTimeToLive": 300,
    //"MaxRetry": 3,

    "Host": "rcscptdappws10",
    // update rabbbit server to use svc_rabbitmqloggingD instead of svc_rabbitmqlogging_d
    "Username": "svc_rabbitmqlogging_d",
    // use the password from password manager vV5pNE£'E^^$"Q595=£YJ*#a<"Dk==3-/ -- figure out how to handle non compliant json values
    "Password": "svc_rabbitmqlogging_d",
    "ExchangeName": "rabbitmq_logging",
    "ExchangeType": "direct",
    "QueueName": "rabbitmq_logging",
    "RoutingKey": "rabbitmq_logging",
    "MessageTimeToLive": 3600000,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Processor\appsettings.DEV.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Processor\appsettings.json

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "Debug"
      },
      {
        "Name": "File",
        "Args": {
          "Path": "C:/Logs/RabbitMq/Consumers/LogMessage/RCS.RabbitMq.Processor.txt",
          "RollingInterval": "Day"
        }
      }
    ]
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Processor\appsettings.PROD.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Processor\appsettings.SIT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\bin\Debug\net8.0\Config\Processor\appsettings.UAT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Config\Consumer\appsettings.DEV.json

{
  "RCS.RabbitMQ": {
    //"Host": "localhost",
    //"Username": "guest",
    //"Password": "guest",
    //"ExchangeName": "whatsapp",
    //"ExchangeType": "direct",
    //"QueueName": "whatsapp",
    //"RoutingKey": "whatsapp",
    //"MessageTimeToLive": 3600000,
    //"RetryQueueTimeToLive": 300,
    //"MaxRetry": 3

    "Host": "rcscptdappws10",
    // update rabbbit server to use svc_rabbitmqloggingD instead of svc_rabbitmqlogging_d
    "Username": "svc_rabbitmqlogging_d",
    // use the password from password manager vV5pNE£'E^^$"Q595=£YJ*#a<"Dk==3-/ -- figure out how to handle non compliant json values
    "Password": "svc_rabbitmqlogging_d",
    "ExchangeName": "rabbitmq_logging",
    "ExchangeType": "direct",
    "QueueName": "rabbitmq_logging",
    "RoutingKey": "rabbitmq_logging",
    "MessageTimeToLive": 3600000,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Config\Consumer\appsettings.json

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "Debug"
      },
      {
        "Name": "File",
        "Args": {
          "Path": "C:/Logs/RabbitMq/Consumers/Logging/RCS.RabbitMq.Logging.Consumer.txt",
          "RollingInterval": "Day"
        }
      }
    ]
  },
  "RCS.RabbitMQ.Consumer": {
    "ServiceMappings": {
      "Processor": {
        "ProcessorAssembly": "RCS.RabbitMq.Logging.Processor.dll",
        "ProcessorClass": "RCS.RabbitMq.Logging.Processor.ProcessMessages"
      },
      "WhatsAppMessage": {
        "MessageInterface": "RCS.RabbitMq.Logging.Processor.Interfaces.ILogMessage",
        "MessageClass": "RCS.RabbitMq.Logging.Processor.Models.LogMessage",
        "MessageMapper": "RCS.RabbitMq.Logging.Processor.Models.LogMessageMapper"
      }
    },
    "MinConsumerCount": 10,
    "MaxConsumerCount": 50,
    "BatchSize": 2500,
    "InactivityTrigger": 10,
    "NonRetryableExceptions": [
      "System.ArgumentException",
      "System.InvalidOperationException",
      "System.NullReferenceException",
      "System.FormatException",
      "System.NotSupportedException"
    ]
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Config\Consumer\appsettings.PROD.json

{
  "RCS.RabbitMQ": {
    //"Host": "localhost",
    //"Username": "guest",
    //"Password": "guest",
    //"ExchangeName": "whatsapp",
    //"ExchangeType": "direct",
    //"QueueName": "whatsapp",
    //"RoutingKey": "whatsapp",
    //"MessageTimeToLive": 3600000,
    //"RetryQueueTimeToLive": 300,
    //"MaxRetry": 3,

    "Host": "rcscptdappws10",
    // update rabbbit server to use svc_rabbitmqloggingD instead of svc_rabbitmqlogging_d
    "Username": "svc_rabbitmqlogging_d",
    // use the password from password manager vV5pNE£'E^^$"Q595=£YJ*#a<"Dk==3-/ -- figure out how to handle non compliant json values
    "Password": "svc_rabbitmqlogging_d",
    "ExchangeName": "rabbitmq_logging",
    "ExchangeType": "direct",
    "QueueName": "rabbitmq_logging",
    "RoutingKey": "rabbitmq_logging",
    "MessageTimeToLive": 3600000,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Config\Consumer\appsettings.SIT.json

{
  "RCS.RabbitMQ": {
    //"Host": "localhost",
    //"Username": "guest",
    //"Password": "guest",
    //"ExchangeName": "whatsapp",
    //"ExchangeType": "direct",
    //"QueueName": "whatsapp",
    //"RoutingKey": "whatsapp",
    //"MessageTimeToLive": 3600000,
    //"RetryQueueTimeToLive": 300,
    //"MaxRetry": 3,

    "Host": "rcscptdappws10",
    // update rabbbit server to use svc_rabbitmqloggingD instead of svc_rabbitmqlogging_d
    "Username": "svc_rabbitmqlogging_d",
    // use the password from password manager vV5pNE£'E^^$"Q595=£YJ*#a<"Dk==3-/ -- figure out how to handle non compliant json values
    "Password": "svc_rabbitmqlogging_d",
    "ExchangeName": "rabbitmq_logging",
    "ExchangeType": "direct",
    "QueueName": "rabbitmq_logging",
    "RoutingKey": "rabbitmq_logging",
    "MessageTimeToLive": 3600000,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMQ.Consumer\RCS.RabbitMq.Consumer\Config\Consumer\appsettings.UAT.json

{
  "RCS.RabbitMQ": {
    //"Host": "localhost",
    //"Username": "guest",
    //"Password": "guest",
    //"ExchangeName": "whatsapp",
    //"ExchangeType": "direct",
    //"QueueName": "whatsapp",
    //"RoutingKey": "whatsapp",
    //"MessageTimeToLive": 3600000,
    //"RetryQueueTimeToLive": 300,
    //"MaxRetry": 3,

    "Host": "rcscptdappws10",
    // update rabbbit server to use svc_rabbitmqloggingD instead of svc_rabbitmqlogging_d
    "Username": "svc_rabbitmqlogging_d",
    // use the password from password manager vV5pNE£'E^^$"Q595=£YJ*#a<"Dk==3-/ -- figure out how to handle non compliant json values
    "Password": "svc_rabbitmqlogging_d",
    "ExchangeName": "rabbitmq_logging",
    "ExchangeType": "direct",
    "QueueName": "rabbitmq_logging",
    "RoutingKey": "rabbitmq_logging",
    "MessageTimeToLive": 3600000,
    "RetryQueueTimeToLive": 300,
    "MaxRetry": 3
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Message.cs

using Microsoft.CSharp.RuntimeBinder;
using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Configuration;
using Serilog;
using System.Data;
namespace RCS.RabbitMq.Logging.Processor;




public class ProcessMessages
{
    
    private static readonly DataTable LogDataTable = SetupDataTable();
    
    private static readonly object TableLock = new();
    
    private static readonly int ChunkSize;
    private static readonly string ConnectionString;
    private static readonly string StoredProcedure;
    private static readonly string ParameterName;
    private static readonly string TypeName;
    
    
    
    static ProcessMessages()
    {
        try
        {
            var environmentName = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "PROD";
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("Config/Processor/appsettings.json", optional: true, reloadOnChange: true)
                .AddJsonFile($"Config/Processor/appsettings.{environmentName}.json", optional: true, reloadOnChange: true)
                .Build();
            var minimumLogLevel = configuration.GetSection("Serilog:MinimumLevel:Default").Value ?? "Information";
            if (!Enum.TryParse<Serilog.Events.LogEventLevel>(minimumLogLevel, true, out var logLevel))
            {
                logLevel = Serilog.Events.LogEventLevel.Information;
            }
            var filePath = configuration.GetSection("Serilog:WriteTo")
                .GetChildren()
                .FirstOrDefault(writeTo => writeTo.GetValue<string>("Name") == "File")
                ?.GetSection("Args")
                .GetValue<string>("Path");
            if (!string.IsNullOrWhiteSpace(filePath))
            {
                var directory = Path.GetDirectoryName(filePath);
                var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(filePath);
                var extension = Path.GetExtension(filePath);
                var modifiedPath = Path.Combine(directory ?? string.Empty, $"{fileNameWithoutExtension}_Processor_{extension}");
                if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }
                Log.Logger = new LoggerConfiguration()
                    .MinimumLevel.Is(logLevel)
                    .WriteTo.Console()
                    .WriteTo.File(modifiedPath, rollingInterval: RollingInterval.Day)
                    .CreateLogger();
                Log.Information("Serilog initialized with modified file path: {ModifiedPath}", modifiedPath);
            }
            else
            {
                throw new InvalidOperationException("Failed to find the file path in configuration.");
            }
            var settingsSection = configuration.GetSection("RCS.RabbitMQ.Consumer.Processor")
                                  ?? throw new InvalidOperationException("Configuration section 'RCS.RabbitMQ.Consumer.Processor' is missing.");
            ConnectionString = settingsSection.GetValue<string>("ConnectionString")
                               ?? throw new ArgumentException("ConnectionString is not configured or is empty in appsettings.json.");
            StoredProcedure = settingsSection.GetValue<string>("StoredProcedure")
                              ?? throw new ArgumentException("StoredProcedure is not configured or is empty in appsettings.json.");
            ParameterName = settingsSection.GetValue<string>("ParameterName")
                            ?? throw new ArgumentException("ParameterName is not configured or is empty in appsettings.json.");
            TypeName = settingsSection.GetValue<string>("TypeName")
                       ?? throw new ArgumentException("TypeName is not configured or is empty in appsettings.json.");
            ChunkSize = settingsSection.GetValue<int?>("ChunkSize") ?? throw new ArgumentException("ChunkSize is not configured or is invalid in appsettings.json.");
            if (ChunkSize <= 0)
            {
                throw new ArgumentException("ChunkSize must be a positive integer.");
            }
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Error during configuration loading.");
            throw;
        }
    }
    
    
    
    
    
    
    public static bool Process<T>(IEnumerable<T>? messages)
    {
        if (messages == null)
        {
            return false;
        }
        lock (TableLock)
        {
            foreach (var message in messages)
            {
                if (message == null)
                {
                    continue;
                }
                try
                {
                    AddLogEntry((dynamic)message);
                }
                catch (RuntimeBinderException ex)
                {
                    Log.Error($"Failed to process message: {ex.Message}");
                }
            }
        }
        return FlushLogs();
    }
    
    private static void AddLogEntry(object message)
    {
        dynamic dynamicMessage = message;
        var properties = SafeGetDynamicProperty(dynamicMessage, nameof(dynamicMessage.Properties));
        if (properties == null) return;
        var row = LogDataTable.NewRow();
        row["ApplicationId"] = Convert.ToInt16(SafeGetDynamicProperty(properties, nameof(properties.ApplicationId))) ?? 0;
        row["MachineName"] = SafeGetDynamicProperty(properties, nameof(properties.MachineName)) ?? string.Empty;
        row["Level"] = dynamicMessage.Level ?? string.Empty;
        row["CorrelationId"] = SafeGetDynamicProperty(properties, nameof(properties.CorrelationId)) ?? Guid.Empty;
        row["Reference"] = SafeGetDynamicProperty(properties, nameof(properties.Reference));
        row["Message"] = dynamicMessage.MessageTemplate;
        row["Logger"] = SafeGetDynamicProperty(properties, nameof(properties.Logger));
        row["AppGeneratedDateTime"] = SafeGetDynamicProperty(properties, nameof(properties.AppGeneratedDateTime));
        row["LogInsertDateTime"] = DateTime.Now;
        LogDataTable.Rows.Add(row);
    }
    
    
    
    
    public static bool FlushLogs()
    {
        DataTable batch;
        lock (TableLock)
        {
            batch = LogDataTable.Copy();
            LogDataTable.Clear();
        }
        return BulkInsertInBatches(batch);
    }
    
    private static bool BulkInsertInBatches(DataTable batch)
    {
        var batches = batch.AsEnumerable()
            .Select((row, index) => new { Row = row, Index = index })
            .GroupBy(x => x.Index / ChunkSize)
            .Select(g => g.Select(x => x.Row).CopyToDataTable())
            .ToList();
        try
        {
            return batches.Select(BulkInsertLogs).All(result => result);
        }
        catch (Exception ex)
        {
            Log.Error($"Error during bulk insert: {ex.Message}");
            throw;
        }
    }
    
    private static DataTable SetupDataTable()
    {
        var table = new DataTable();
        table.Columns.Add("ApplicationId", typeof(short));
        table.Columns.Add("MachineName", typeof(string));
        table.Columns.Add("Level", typeof(string));
        table.Columns.Add("CorrelationId", typeof(Guid));
        table.Columns.Add("Reference", typeof(string));
        table.Columns.Add("Message", typeof(string));
        table.Columns.Add("Logger", typeof(string));
        table.Columns.Add("AppGeneratedDateTime", typeof(DateTime));
        table.Columns.Add("LogInsertDateTime", typeof(DateTime));
        return table;
    }
    
    private static object? SafeGetDynamicProperty(dynamic obj, string propertyName)
    {
        if (obj == null) return null;
        try
        {
            return obj.GetType().GetProperty(propertyName)?.GetValue(obj, null);
        }
        catch
        {
            return null;
        }
    }
    
    
    
    
    
    public static bool BulkInsertLogs(DataTable logDataTable)
    {
        using var sqlConnection = new SqlConnection(ConnectionString);
        sqlConnection.Open();
        using var sqlTransaction = sqlConnection.BeginTransaction();
        try
        {
            ExecuteBulkInsert(sqlTransaction, logDataTable);
            sqlTransaction.Commit();
            return true;
        }
        catch (Exception ex)
        {
            Log.Error($"Error during bulk insert: {ex.Message}");
            sqlTransaction.Rollback();
            throw;
        }
    }
    
    private static void ExecuteBulkInsert(SqlTransaction sqlTransaction, DataTable logDataTable)
    {
        using var sqlCommand = new SqlCommand(StoredProcedure, sqlTransaction.Connection, sqlTransaction)
        {
            CommandType = CommandType.StoredProcedure,
            CommandTimeout = 30
        };
        sqlCommand.Parameters.Add(new SqlParameter
        {
            ParameterName = ParameterName,
            SqlDbType = SqlDbType.Structured,
            TypeName = TypeName,
            Value = logDataTable
        });
        sqlCommand.ExecuteNonQuery();
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Interfaces\ILogMessage.cs

using RCS.RabbitMq.Logging.Processor.Models;
using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Logging.Processor.Interfaces;




public interface ILogMessage : IBasicMessageContract
{
    
    
    
    string? Level { get; set; }
    
    
    
    string? MessageTemplate { get; set; }
    
    
    
    LogMessageProperties? Properties { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Models\LogMessage.cs

using System.Text.Json.Serialization;
using RCS.RabbitMq.Logging.Processor.Interfaces;
namespace RCS.RabbitMq.Logging.Processor.Models;




public class LogMessage : ILogMessage
{
    
    
    
    [JsonPropertyName("Level")]
    public string? Level { get; set; }
    
    
    
    [JsonPropertyName("MessageTemplate")]
    public string? MessageTemplate { get; set; }
    
    
    
    [JsonPropertyName("Properties")]
    public LogMessageProperties? Properties { get; set; }
    
    
    
    [JsonIgnore]
    public ulong DeliveryTag { get; set; }
    
    
    
    [JsonIgnore]
    public IDictionary<string, object>? Headers { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Models\LogMessageMapper.cs

using RCS.RabbitMq.Logging.Processor.Interfaces;
using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Logging.Processor.Models;




public class LogMessageMapper : IRabbitMessageMapper<IAcknowledgeableRabbitMessage, ILogMessage>
{
    
    
    
    
    
    public ILogMessage Map(IAcknowledgeableRabbitMessage input)
    {
        return new LogMessage
        {
            DeliveryTag = input.DeliveryTag,
            Headers = input.Headers
        };
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Models\LogMessageProperties.cs

using System.Text.Json.Serialization;
namespace RCS.RabbitMq.Logging.Processor.Models;




public class LogMessageProperties
{
    
    
    
    
    [JsonPropertyName("Logger")]
    public required string Logger { get; set; }
    
    
    
    
    [JsonPropertyName("Reference")]
    public required string Reference { get; set; }
    
    
    
    
    [JsonPropertyName("CorrelationId")]
    public required string CorrelationId { get; set; }
    
    
    
    
    [JsonPropertyName("MachineName")]
    public required string MachineName { get; set; }
    
    
    
    
    [JsonPropertyName("ApplicationId")]
    public int ApplicationId { get; set; }
    
    
    
    
    [JsonPropertyName("AppGeneratedDateTime")]
    public DateTime AppGeneratedDateTime { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs


using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\obj\Debug\net8.0\RCS.RabbitMq.Logging.Processor.AssemblyInfo.cs










using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("RCS.RabbitMq.Logging.Processor")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+a6cb8f42d7e61306bef908b3bfec778b891c1ca4")]
[assembly: System.Reflection.AssemblyProductAttribute("RCS.RabbitMq.Logging.Processor")]
[assembly: System.Reflection.AssemblyTitleAttribute("RCS.RabbitMq.Logging.Processor")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\obj\Debug\net8.0\RCS.RabbitMQ.Logging.Processor.GlobalUsings.g.cs


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\bin\Debug\net8.0\Config\Processor\appsettings.DEV.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\bin\Debug\net8.0\Config\Processor\appsettings.json

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "Debug"
      },
      {
        "Name": "File",
        "Args": {
          "Path": "C:/Logs/RabbitMq/Consumers/LogMessage/RCS.RabbitMq.Processor.txt",
          "RollingInterval": "Day"
        }
      }
    ]
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\bin\Debug\net8.0\Config\Processor\appsettings.PROD.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\bin\Debug\net8.0\Config\Processor\appsettings.SIT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\bin\Debug\net8.0\Config\Processor\appsettings.UAT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Config\Processor\appsettings.DEV.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Config\Processor\appsettings.json

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "Debug"
      },
      {
        "Name": "File",
        "Args": {
          "Path": "C:/Logs/RabbitMq/Consumers/LogMessage/RCS.RabbitMq.Processor.txt",
          "RollingInterval": "Day"
        }
      }
    ]
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Config\Processor\appsettings.PROD.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Config\Processor\appsettings.SIT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Logging.Processor\RCS.RabbitMq.Logging.Processor\Config\Processor\appsettings.UAT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.RabbitMq.Logging;Integrated Security=True;TrustServerCertificate=True;",
    "StoredProcedure": "up_Log_Insert_Bulk",
    "ParameterName": "@LogEntries",
    "TypeName": "dbo.LogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Shared\RCS.RabbitMq.Shared\Interfaces\IAcknowledgeableRabbitMessage.cs

namespace RCS.RabbitMq.Shared.Interfaces;



public interface IAcknowledgeableRabbitMessage
{
    
    
    
    
    ulong DeliveryTag { get; set; }
    
    
    
    IDictionary<string, object>? Headers { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Shared\RCS.RabbitMq.Shared\Interfaces\IBasicMessageContract.cs

namespace RCS.RabbitMq.Shared.Interfaces;




public interface IBasicMessageContract : IAcknowledgeableRabbitMessage;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Shared\RCS.RabbitMq.Shared\Interfaces\IConfigurationIntegrityValidator.cs

using Microsoft.Extensions.Configuration;
namespace RCS.RabbitMq.Shared.Interfaces;




public interface IConfigurationIntegrityValidator
{
    
    
    
    
    
    void Validate(IConfigurationSection section);
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Shared\RCS.RabbitMq.Shared\Interfaces\IRabbitMessageMapper.cs

namespace RCS.RabbitMq.Shared.Interfaces;










public interface IRabbitMessageMapper<in TInput, out TOutput>
    where TInput : IAcknowledgeableRabbitMessage
    where TOutput : IBasicMessageContract
{
    
    
    
    
    
    TOutput Map(TInput input);
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Shared\RCS.RabbitMq.Shared\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs


using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Shared\RCS.RabbitMq.Shared\obj\Debug\net8.0\RCS.RabbitMq.Shared.AssemblyInfo.cs










using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("RCS.RabbitMq.Shared")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0-beta+c9963b7f0fed6dc352e36329deca9beaf9930695")]
[assembly: System.Reflection.AssemblyProductAttribute("RCS.RabbitMq.Shared")]
[assembly: System.Reflection.AssemblyTitleAttribute("RCS.RabbitMq.Shared")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Shared\RCS.RabbitMq.Shared\obj\Debug\net8.0\RCS.RabbitMq.Shared.GlobalUsings.g.cs


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Shared\RCS.RabbitMq.Shared\Processor\ProcessMessagesBase.cs

using Microsoft.Data.SqlClient;
using Serilog;
using System.Data;
namespace RCS.RabbitMq.Shared.Processor;




public abstract class ProcessMessagesBase(DataTable bufferDataTable)
{
    
    
    
    protected readonly DataTable BufferDataTable = bufferDataTable ?? throw new ArgumentNullException(nameof(bufferDataTable));
    
    
    
    protected readonly object TableLock = new();
    
    
    
    
    
    
    protected static Dictionary<string, object?> SafeGetAllMembers(object? obj)
    {
        var result = new Dictionary<string, object?>();
        if (obj == null) return result;
        try
        {
            var type = obj.GetType();
            foreach (var prop in type.GetProperties())
                result[prop.Name] = prop.GetValue(obj);
            foreach (var field in type.GetFields())
                result[field.Name] = field.GetValue(obj);
        }
        catch (Exception ex)
        {
            Log.Error("SafeGetAllMembers() failed: {Message}", ex.Message);
            throw;
        }
        return result;
    }
    
    
    
    
    
    
    
    protected bool FlushBuffer(int chunkSize, Func<DataTable, bool> bulkInsertHandler)
    {
        DataTable batch;
        lock (TableLock)
        {
            batch = BufferDataTable.Copy();
            BufferDataTable.Clear();
        }
        return BulkInsertBufferEntriesInBatches(batch, chunkSize, bulkInsertHandler);
    }
    
    
    
    
    
    
    
    protected static bool BulkInsertBufferEntriesInBatches(DataTable dataTable, int chunkSize, Func<DataTable, bool> insertFunc)
    {
        try
        {
            return dataTable.AsEnumerable()
                .Select((row, index) => new { Row = row, Index = index })
                .GroupBy(x => x.Index / chunkSize)
                .Select(g => g.Select(x => x.Row).CopyToDataTable())
                .All(insertFunc);
        }
        catch (Exception ex)
        {
            Log.Error("Error in BulkInsertBufferEntriesInBatches: {Message}", ex.Message);
            throw;
        }
    }
    
    
    
    
    
    
    
    
    
    protected static bool BulkInsertBufferEntries(DataTable dataTable, string connectionString, string storedProcedure, string parameterName, string typeName)
    {
        using var sqlConnection = new SqlConnection(connectionString);
        sqlConnection.Open();
        using var sqlTransaction = sqlConnection.BeginTransaction();
        try
        {
            ExecuteBulkInsert(sqlTransaction, dataTable, storedProcedure, parameterName, typeName);
            sqlTransaction.Commit();
            return true;
        }
        catch (Exception ex)
        {
            Log.Error("Error in BulkInsertBufferEntries: {Message}", ex.Message);
            sqlTransaction.Rollback();
            throw;
        }
    }
    
    
    
    
    
    
    
    
    protected static void ExecuteBulkInsert(SqlTransaction sqlTransaction, DataTable dataTable, string storedProcedure, string parameterName, string typeName)
    {
        using var sqlCommand = new SqlCommand(storedProcedure, sqlTransaction.Connection, sqlTransaction);
        sqlCommand.CommandType = CommandType.StoredProcedure;
        sqlCommand.CommandTimeout = 30;
        sqlCommand.Parameters.Add(new SqlParameter
        {
            ParameterName = parameterName,
            SqlDbType = SqlDbType.Structured,
            TypeName = typeName,
            Value = dataTable
        });
        sqlCommand.ExecuteNonQuery();
    }
    
    
    
    
    
    protected abstract void AddBufferEntry(object incomingMessage);
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.Shared\RCS.RabbitMq.Shared\Services\ConfigurationIntegrityValidator.cs

using Microsoft.Extensions.Configuration;
using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMq.Shared.Services;




public class ConfigurationIntegrityValidator : IConfigurationIntegrityValidator
{
    
    
    
    
    
    public void Validate(IConfigurationSection section)
    {
        foreach (var key in section.GetChildren())
        {
            
            if (key.Key is "NonRetryableExceptions" or "ServiceMappings")
            {
                switch (key.Key)
                {
                    case "NonRetryableExceptions":
                        ValidateNonRetryableExceptionsSection(key);
                        break;
                    case "ServiceMappings":
                        ValidateServiceMappingsSection(key);
                        break;
                }
                continue;
            }
            
            if (string.IsNullOrEmpty(section[key.Key]))
            {
                throw new ArgumentException($"'{key.Key}' is missing or null in configuration.");
            }
        }
    }
    
    
    
    
    private static void ValidateNonRetryableExceptionsSection(IConfigurationSection exceptionsSection)
    {
        var exceptions = exceptionsSection.GetChildren().Select(e => e.Value).ToList();
        if (exceptions.Count == 0)
        {
            throw new ArgumentException("'NonRetryableExceptions' section is missing or empty.");
        }
        foreach (var exception in exceptions)
        {
            if (string.IsNullOrWhiteSpace(exception))
            {
                throw new ArgumentException("One of the 'NonRetryableExceptions' entries is null or empty.");
            }
            var exceptionType = Type.GetType(exception);
            if (exceptionType == null || !typeof(Exception).IsAssignableFrom(exceptionType))
            {
                throw new ArgumentException($"'{exception}' is not a valid exception type.");
            }
        }
    }
    
    
    
    
    private static void ValidateServiceMappingsSection(IConfigurationSection serviceMappingsSection)
    {
        foreach (var mapping in serviceMappingsSection.GetChildren())
        {
            foreach (var service in mapping.GetChildren())
            {
                if (string.IsNullOrEmpty(service.Value))
                {
                    throw new ArgumentException($"Service mapping for '{service.Key}' is missing or null.");
                }
            }
        }
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\Message.cs

using Microsoft.CSharp.RuntimeBinder;
using Microsoft.Extensions.Configuration;
using RCS.RabbitMq.Shared.Processor;
using Serilog;
using System.Data;
namespace RCS.RabbitMQ.WhatsApp.ActionLog.Processor;



public class ProcessMessages() : ProcessMessagesBase(CreateBufferSchema())
{
    private static readonly int ChunkSize;
    private static readonly string ConnectionString;
    private static readonly string StoredProcedure;
    private static readonly string ParameterName;
    private static readonly string TypeName;
    
    
    
    static ProcessMessages()
    {
        try
        {
            var environmentName = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "PROD";
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("Config/Processor/appsettings.json", optional: true, reloadOnChange: true)
                .AddJsonFile($"Config/Processor/appsettings.{environmentName}.json", optional: true, reloadOnChange: true)
                .Build();
            var minimumLogLevel = configuration["Serilog:MinimumLevel:Default"] ?? "Information";
            if (!Enum.TryParse(minimumLogLevel, true, out Serilog.Events.LogEventLevel logLevel))
                logLevel = Serilog.Events.LogEventLevel.Information;
            var filePath = configuration.GetSection("Serilog:WriteTo")
                .GetChildren()
                .FirstOrDefault(w => w.GetValue<string>("Name") == "File")?
                .GetSection("Args")
                .GetValue<string>("Path");
            if (string.IsNullOrWhiteSpace(filePath))
                throw new InvalidOperationException("Failed to find the file path in configuration.");
            var directory = Path.GetDirectoryName(filePath);
            var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(filePath);
            var extension = Path.GetExtension(filePath);
            var modifiedPath = Path.Combine(directory ?? string.Empty, $"{fileNameWithoutExtension}_Processor_{extension}");
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                Directory.CreateDirectory(directory);
            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Is(logLevel)
                .WriteTo.Console()
                .WriteTo.File(modifiedPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();
            Log.Information("Serilog initialized with modified file path: {ModifiedPath}", modifiedPath);
            var settingsSection = configuration.GetSection("RCS.RabbitMQ.Consumer.Processor")
                ?? throw new InvalidOperationException("Configuration section 'RCS.RabbitMQ.Consumer.Processor' is missing.");
            ConnectionString = settingsSection.GetValue<string>("ConnectionString")
                ?? throw new ArgumentException("ConnectionString is not configured.");
            StoredProcedure = settingsSection.GetValue<string>("StoredProcedure")
                ?? throw new ArgumentException("StoredProcedure is not configured.");
            ParameterName = settingsSection.GetValue<string>("ParameterName")
                ?? throw new ArgumentException("ParameterName is not configured.");
            TypeName = settingsSection.GetValue<string>("TypeName")
                ?? throw new ArgumentException("TypeName is not configured.");
            ChunkSize = settingsSection.GetValue<int?>("ChunkSize")
                ?? throw new ArgumentException("ChunkSize is not configured.");
            if (ChunkSize <= 0)
                throw new ArgumentException("ChunkSize must be a positive integer.");
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Error during configuration loading.");
            throw;
        }
    }
    
    
    
    private static DataTable CreateBufferSchema()
    {
        var table = new DataTable();
        table.Columns.Add("SessionToken", typeof(Guid));
        table.Columns.Add("AuthSessionToken", typeof(Guid));
        table.Columns.Add("LogoCode", typeof(string));
        table.Columns.Add("MobileNumber", typeof(string));
        table.Columns.Add("ActionId", typeof(int));
        table.Columns.Add("Message", typeof(string));
        table.Columns.Add("CreatedOn", typeof(DateTime));
        table.Columns.Add("CreatedBy", typeof(string));
        return table;
    }
    
    
    
    public bool Process<T>(IEnumerable<T>? messages)
    {
        try
        {
            if (messages == null) return false;
            lock (TableLock)
            {
                foreach (var message in messages)
                {
                    if (message == null) continue;
                    try
                    {
                        AddBufferEntry((dynamic)message);
                    }
                    catch (RuntimeBinderException ex)
                    {
                        Log.Error("Failed to process message: {Message}", ex.Message);
                    }
                }
            }
            return FlushBuffer(ChunkSize, dataTable =>
                BulkInsertBufferEntries(dataTable, ConnectionString, StoredProcedure, ParameterName, TypeName));
        }
        catch (Exception ex)
        {
            Log.Error("Process() failed: {Message}", ex.Message);
            throw;
        }
    }
    
    
    
    
    protected override void AddBufferEntry(object incomingMessage)
    {
        var properties = SafeGetAllMembers(incomingMessage);
        if (properties.Count == 0) return;
        properties.TryGetValue("SessionToken", out var sessionTokenObj);
        properties.TryGetValue("AuthSessionToken", out var authSessionTokenObj);
        properties.TryGetValue("LogoCode", out var logoCodeObj);
        properties.TryGetValue("MobileNumber", out var mobileNumberObj);
        properties.TryGetValue("ActionId", out var actionIdObj);
        properties.TryGetValue("Message", out var messageObj);
        properties.TryGetValue("CreatedOn", out var createdOnValueObj);
        properties.TryGetValue("CreatedBy", out var createdByObj);
        if (string.IsNullOrWhiteSpace(mobileNumberObj?.ToString()))
            throw new ArgumentException("MobileNumber is required.");
        if (actionIdObj == null || !int.TryParse(actionIdObj.ToString(), out var actionId))
            throw new ArgumentException("Valid ActionId is required.");
        if (createdOnValueObj == null || !DateTime.TryParse(createdOnValueObj.ToString(), out var createdOn))
            throw new ArgumentException("Valid CreatedOn is required.");
        var row = BufferDataTable.NewRow();
        row["SessionToken"] = sessionTokenObj ?? Guid.Empty;
        row["AuthSessionToken"] = authSessionTokenObj ?? Guid.Empty;
        row["LogoCode"] = logoCodeObj ?? string.Empty;
        row["MobileNumber"] = mobileNumberObj;
        row["ActionId"] = actionId;
        row["Message"] = messageObj ?? string.Empty;
        row["CreatedOn"] = createdOn;
        row["CreatedBy"] = createdByObj ?? string.Empty;
        BufferDataTable.Rows.Add(row);
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\Interfaces\IWhatsAppMessage.cs

using System.Text.Json.Serialization;
using RCS.RabbitMq.Shared.Interfaces;
namespace RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Interfaces;




public interface IWhatsAppMessage : IBasicMessageContract
{
    
    
    
    [JsonPropertyName("SessionToken")]
    Guid? SessionToken { get; set; }
    
    
    
    
    [JsonPropertyName("AuthSessionToken")]
    Guid? AuthSessionToken { get; set; }
    
    
    
    [JsonPropertyName("LogoCode")]
    string? LogoCode { get; set; }
    
    
    
    [JsonPropertyName("MobileNumber")]
    string MobileNumber { get; set; }
    
    
    
    [JsonPropertyName("ActionId")]
    int ActionId { get; set; }
    
    
    
    [JsonPropertyName("Message")]
    string? Message { get; set; }
    
    
    
    [JsonPropertyName("CreatedOn")]
    DateTime CreatedOn { get; set; }
    
    
    
    [JsonPropertyName("CreatedBy")]
    string? CreatedBy { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\Models\WhatsAppMessage.cs

using System.Text.Json.Serialization;
using RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Interfaces;
namespace RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Models;




public class WhatsAppMessage : IWhatsAppMessage
{
    
    
    
    [JsonPropertyName("SessionToken")]
    public Guid? SessionToken { get; set; }
    
    
    
    [JsonPropertyName("AuthSessionToken")]
    public Guid? AuthSessionToken { get; set; }
    
    
    
    [JsonPropertyName("LogoCode")]
    public string? LogoCode { get; set; }
    
    
    
    [JsonPropertyName("MobileNumber")]
    public string MobileNumber { get; set; } = string.Empty;
    
    
    
    [JsonPropertyName("ActionId")]
    public int ActionId { get; set; }
    
    
    
    [JsonPropertyName("Message")]
    public string? Message { get; set; }
    
    
    
    [JsonPropertyName("CreatedOn")]
    public DateTime CreatedOn { get; set; }
    
    
    
    [JsonPropertyName("CreatedBy")]
    public string? CreatedBy { get; set; }
    
    
    
    [JsonIgnore]
    public ulong DeliveryTag { get; set; }
    
    
    
    [JsonIgnore]
    public IDictionary<string, object>? Headers { get; set; }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\Models\WhatsAppMessageMapper.cs

using RCS.RabbitMq.Shared.Interfaces;
using RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Interfaces;
namespace RCS.RabbitMQ.WhatsApp.ActionLog.Processor.Models;




public class WhatsAppMessageMapper : IRabbitMessageMapper<IAcknowledgeableRabbitMessage, IWhatsAppMessage>
{
    
    
    
    
    
    public IWhatsAppMessage Map(IAcknowledgeableRabbitMessage input)
    {
        return new WhatsAppMessage
        {
            DeliveryTag = input.DeliveryTag,
            Headers = input.Headers
        };
    }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs


using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\obj\Debug\net8.0\RCS.RabbitMq.WhatsApp.ActionLog.Processor.AssemblyInfo.cs










using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("RCS.RabbitMq.WhatsApp.ActionLog.Processor")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+55a3e4c33903b82175d5d91cdee1e0336bbb5791")]
[assembly: System.Reflection.AssemblyProductAttribute("RCS.RabbitMq.WhatsApp.ActionLog.Processor")]
[assembly: System.Reflection.AssemblyTitleAttribute("RCS.RabbitMq.WhatsApp.ActionLog.Processor")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\obj\Debug\net8.0\RCS.RabbitMq.WhatsApp.ActionLog.Processor.GlobalUsings.g.cs


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\bin\Debug\net8.0\Config\Processor\appsettings.DEV.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    //"ConnectionString": "Server=localhost;Database=RCS.CM.ActionLog;User Id=sa;Password=Spooky58466!;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ParameterName": "@ActionLogs",
    "TypeName": "dbo.ActionLogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\bin\Debug\net8.0\Config\Processor\appsettings.json

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "Debug"
      },
      {
        "Name": "File",
        "Args": {
          "Path": "C:/Logs/RabbitMq/Consumers/WhatsApp/WhatsApp.Processor.txt",
          "RollingInterval": "Day"
        }
      }
    ]
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\bin\Debug\net8.0\Config\Processor\appsettings.PROD.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    //"ConnectionString": "Server=localhost;Database=RCS.CM.ActionLog;User Id=sa;Password=Spooky58466!;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ParameterName": "@ActionLogs",
    "TypeName": "dbo.ActionLogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\bin\Debug\net8.0\Config\Processor\appsettings.SIT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    //"ConnectionString": "Server=localhost;Database=RCS.CM.ActionLog;User Id=sa;Password=Spooky58466!;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ParameterName": "@ActionLogs",
    "TypeName": "dbo.ActionLogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\bin\Debug\net8.0\Config\Processor\appsettings.UAT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    //"ConnectionString": "Server=localhost;Database=RCS.CM.ActionLog;User Id=sa;Password=Spooky58466!;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ParameterName": "@ActionLogs",
    "TypeName": "dbo.ActionLogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\Config\Processor\appsettings.DEV.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    //"ConnectionString": "Server=localhost;Database=RCS.CM.ActionLog;User Id=sa;Password=Spooky58466!;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ParameterName": "@ActionLogs",
    "TypeName": "dbo.ActionLogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\Config\Processor\appsettings.json

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "Debug"
      },
      {
        "Name": "File",
        "Args": {
          "Path": "C:/Logs/RabbitMq/Consumers/WhatsApp/WhatsApp.Processor.txt",
          "RollingInterval": "Day"
        }
      }
    ]
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\Config\Processor\appsettings.PROD.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    //"ConnectionString": "Server=localhost;Database=RCS.CM.ActionLog;User Id=sa;Password=Spooky58466!;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ParameterName": "@ActionLogs",
    "TypeName": "dbo.ActionLogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\Config\Processor\appsettings.SIT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    //"ConnectionString": "Server=localhost;Database=RCS.CM.ActionLog;User Id=sa;Password=Spooky58466!;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ParameterName": "@ActionLogs",
    "TypeName": "dbo.ActionLogType",
    "ChunkSize": 2500
  }
}

// File: C:\Projects\RCS\RCS.RabbitMq\RCS.RabbitMq\RCS.RabbitMq.WhatsApp.ActionLog.Processor\RCS.RabbitMq.WhatsApp.ActionLog.Processor\Config\Processor\appsettings.UAT.json

{
  "RCS.RabbitMQ.Consumer.Processor": {
    "ConnectionString": "Server=RCSCPTDDB10;Database=RCS.CM.ActionLog;Integrated Security=True;TrustServerCertificate=True;",
    //"ConnectionString": "Server=localhost;Database=RCS.CM.ActionLog;User Id=sa;Password=Spooky58466!;TrustServerCertificate=True;",
    "StoredProcedure": "sp_ActionLog_BulkInsert",
    "ParameterName": "@ActionLogs",
    "TypeName": "dbo.ActionLogType",
    "ChunkSize": 2500
  }
}
